diff --git a/arch/arm/configs/omap2plus_defconfig b/arch/arm/configs/omap2plus_defconfig
index ccedde1..27e1e28 100644
--- a/arch/arm/configs/omap2plus_defconfig
+++ b/arch/arm/configs/omap2plus_defconfig
@@ -183,6 +183,7 @@ CONFIG_TWL4030_WATCHDOG=y
 CONFIG_MENELAUS=y
 CONFIG_TWL4030_CORE=y
 CONFIG_TWL4030_POWER=y
+CONFIG_TWL4030_SCRIPT=m
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_TWL4030=y
 CONFIG_REGULATOR_TPS65023=y
diff --git a/arch/arm/configs/omap3_beagle_defconfig b/arch/arm/configs/omap3_beagle_defconfig
index cef7597..f41dfe9 100644
--- a/arch/arm/configs/omap3_beagle_defconfig
+++ b/arch/arm/configs/omap3_beagle_defconfig
@@ -262,6 +262,7 @@ CONFIG_SMSC911X=y
 # USB Network Adapters
 #
 CONFIG_USB_USBNET=y
+CONFIG_USB_NET_SMSC95XX=y
 CONFIG_USB_ALI_M5632=y
 CONFIG_USB_AN2720=y
 CONFIG_USB_EPSON2888=y
@@ -447,6 +448,7 @@ CONFIG_SND_USB_AUDIO=y
 CONFIG_SND_SOC=y
 CONFIG_SND_OMAP_SOC=y
 CONFIG_SND_OMAP_SOC_OMAP3EVM=y
+CONFIG_SND_OMAP_SOC_OMAP3_BEAGLE=y
 CONFIG_SND_SOC_I2C_AND_SPI=y
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=y
diff --git a/arch/arm/mach-omap2/board-am35xpia.c b/arch/arm/mach-omap2/board-am35xpia.c
index 9e94ffa..d6585b2 100644
--- a/arch/arm/mach-omap2/board-am35xpia.c
+++ b/arch/arm/mach-omap2/board-am35xpia.c
@@ -356,6 +356,10 @@ static void __init pia35x_display_init(void)
 inline static void __init pia35x_display_init(void) { }
 #endif /* PIA_DVI || PIA_LCD */
 
+/** SPI GPIO CS Hack **/
+//int mcspi1_cs_gpios[4];
+int mcspi2_cs_gpios[4];
+
 /** piA-MotorControl **/
 #if defined(CONFIG_SPI_SPIDEV) || defined(CONFIG_SPI_SPIDEV_MODULE)
 #include <plat/mcspi.h>
@@ -363,7 +367,6 @@ inline static void __init pia35x_display_init(void) { }
 
 //#define SYS_CLKOUT2_PARENT	"omap_54m_fck"
 #define SYS_CLKOUT2_PARENT	"cm_96m_fck"
-
 static struct omap2_mcspi_device_config pia35x_motor_x_cfg = {
 	.turbo_mode       = 0,
 	.single_channel   = 1,
@@ -834,6 +837,262 @@ static inline void __init pia35x_io_init(void) {
 }
 #endif /* CONFIG_GPIO_PCF857X */
 
+/** piA-EMS_IO **/
+#if (defined(CONFIG_GPIO_PCF857X) || defined(CONFIG_GPIO_PCF857X_MODULE)) && \
+	(defined(CONFIG_CAN_MCP251X) || defined(CONFIG_CAN_MCP251X_MODULE)) && \
+	(defined(CONFIG_SERIAL_MAX3100) || defined(CONFIG_SERIAL_MAX3100_MODULE))
+#include <linux/can/platform/mcp251x.h>
+#include <linux/serial_max3100.h>
+
+#define EMS_IO_CAN_DEV(bus, cs, irqgpio, id) \
+{	.modalias      = "mcp2515", \
+	.bus_num       = bus, \
+	.chip_select   = cs, \
+	.max_speed_hz  = 10E6, \
+	.mode          = SPI_MODE_0, \
+	.irq           = OMAP_GPIO_IRQ(irqgpio), \
+	.controller_data = &ems_io_mcp2515_cfg[id], \
+	.platform_data = &ems_io_mcp2515_data[id], \
+}
+#define EMS_IO_485_DEV(bus, cs, irqgpio, id) \
+{ \
+	.modalias      = "max3100", \
+	.bus_num       = bus, \
+	.chip_select   = cs, \
+	.max_speed_hz  = 4E6, /* DS min 238ns period */ \
+	.mode          = SPI_MODE_0, \
+	.irq           = OMAP_GPIO_IRQ(irqgpio), \
+	.controller_data = &ems_io_max3140_cfg[id], \
+	.platform_data = &ems_io_max3140_data[id], \
+}
+#define EMS_IO_GPIO_DEV(ad, irqgpio, id) \
+{	I2C_BOARD_INFO("pca9672", ad), \
+	.irq           = OMAP_GPIO_IRQ(irqgpio), \
+	.platform_data = &ems_io_pca9672_data[id], \
+}
+#define EMS_IO_GPIO_DEV_DATA(id) \
+{	.gpio_base = PIAIO_GPIO_BASE(id), \
+	.setup     = ems_io_gpio_setup, \
+	.teardown  = ems_io_gpio_teardown \
+}
+
+static struct mcp251x_platform_data ems_io_mcp2515_data[3] = {
+	{ .oscillator_frequency = 25E6 }, /* CAN 1 */
+	{ .oscillator_frequency = 25E6 }, /* CAN 2 */
+	{ .oscillator_frequency = 25E6 }, /* CAN 3 */
+};
+
+static struct plat_max3100 ems_io_max3140_data[4] = {
+	{ .loopback = 0, .crystal = 1, .poll_time = 0, .invert_rts = 1 },
+	{ .loopback = 0, .crystal = 1, .poll_time = 0, .invert_rts = 1 },
+	{ .loopback = 0, .crystal = 1, .poll_time = 0, .invert_rts = 1 },
+	{ .loopback = 0, .crystal = 1, .poll_time = 0, .invert_rts = 1 },
+};
+
+/* 3 CAN + 4 RS485 on SPI busses 1+2 */
+static struct omap2_mcspi_device_config ems_io_mcp2515_cfg[] = {
+	{ .turbo_mode	= 0, .single_channel	= 1 },
+	{ .turbo_mode	= 0, .single_channel	= 1 },
+	{ .turbo_mode	= 0, .single_channel	= 1 },
+};
+static struct omap2_mcspi_device_config ems_io_max3140_cfg[] = {
+	{ .turbo_mode	= 0, .single_channel	= 1 },
+	{ .turbo_mode	= 0, .single_channel	= 1 },
+	{ .turbo_mode	= 0, .single_channel	= 1 },
+	{ .turbo_mode	= 0, .single_channel	= 1 },
+};
+static struct spi_board_info pia35x_ems_io_spi_info[] = {
+	EMS_IO_CAN_DEV(1, 0, 132, 0),
+	EMS_IO_CAN_DEV(1, 2, 133, 1),
+	EMS_IO_CAN_DEV(2, 0, 134, 2),
+	EMS_IO_485_DEV(1, 1, 135, 0),
+	EMS_IO_485_DEV(1, 3, 136, 1),
+	EMS_IO_485_DEV(2, 1, 137, 2),
+	EMS_IO_485_DEV(2, 2, 138, 3),
+};
+
+enum {
+	EMS_IO_DOUT,
+	EMS_IO_DIN1,
+	EMS_IO_DIN2,
+	EMS_IO_TERM,
+	EMS_IO_DISP,
+};
+/* mapping of expander GPIOs to names */
+#define EMS_IO_GPIO(e, n, o, ex) \
+{	.expander = e, .name = n, .out = o, .export = ex }
+struct ems_io_gpio_config {
+	unsigned expander; /* expander id */
+	char    *name;     /* exported name */
+	unsigned out;      /* is output? */
+	unsigned export;   /* auto export? */
+};
+
+/* all gpios on expanders ordered by expander + pin */
+static struct ems_io_gpio_config ems_io_gpios[5*8] = {
+	/* DOUT 0..7 */
+	EMS_IO_GPIO(EMS_IO_DOUT, "dout.1", 1, 1),
+	EMS_IO_GPIO(EMS_IO_DOUT, "dout.2", 1, 1),
+	EMS_IO_GPIO(EMS_IO_DOUT, "dout.3", 1, 1),
+	EMS_IO_GPIO(EMS_IO_DOUT, "dout.4", 1, 1),
+	EMS_IO_GPIO(EMS_IO_DOUT, "dout.5", 1, 1),
+	EMS_IO_GPIO(EMS_IO_DOUT, "dout.6", 1, 1),
+	EMS_IO_GPIO(EMS_IO_DOUT, "dout.7", 1, 1),
+	EMS_IO_GPIO(EMS_IO_DOUT, "dout.8", 1, 1),
+	/* DIN 8..19 */
+	EMS_IO_GPIO(EMS_IO_DIN1, "din.1", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN1, "din.2", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN1, "din.3", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN1, "din.4", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN1, "din.5", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN1, "din.6", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN1, "din.7", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN1, "din.8", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN2, "din.9", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN2, "din.10", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN2, "din.11", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN2, "din.12", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DIN2, "display.fehler", 1, 1),
+	EMS_IO_GPIO(EMS_IO_DIN2, NULL, 0, 0),
+	EMS_IO_GPIO(EMS_IO_DIN2, NULL, 0, 0),
+	EMS_IO_GPIO(EMS_IO_DIN2, NULL, 0, 0),
+	/* TERM */
+	EMS_IO_GPIO(EMS_IO_TERM, "term.can.1", 1, 1),
+	EMS_IO_GPIO(EMS_IO_TERM, "term.rs485.1", 1, 1),
+	EMS_IO_GPIO(EMS_IO_TERM, "term.can.2", 1, 1),
+	EMS_IO_GPIO(EMS_IO_TERM, "term.rs485.2", 1, 1),
+	EMS_IO_GPIO(EMS_IO_TERM, "term.can3", 1, 1),
+	EMS_IO_GPIO(EMS_IO_TERM, "term.rs485.3", 1, 1),
+	EMS_IO_GPIO(EMS_IO_TERM, "term.rs485.4", 1, 1),
+	EMS_IO_GPIO(EMS_IO_TERM, NULL, 1, 1),
+	/* DISPLAY */
+	EMS_IO_GPIO(EMS_IO_DISP, "display.enter", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DISP, "display.esc", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DISP, "display.rechts", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DISP, "display.links", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DISP, "display.ab", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DISP, "display.auf", 0, 1),
+	EMS_IO_GPIO(EMS_IO_DISP, "display.led_einspeis", 1, 1),
+	EMS_IO_GPIO(EMS_IO_DISP, "display.led_netz", 1, 1),
+};
+
+static int ems_io_gpio_setup(
+		struct i2c_client *client,
+		int gpio, unsigned ngpio, void *c)
+{
+	int i;
+	int base = gpio - OMAP_MAX_GPIO_LINES;
+	struct ems_io_gpio_config *cur;
+
+	for (i = 0; i < 8; ++i) {
+		cur = &ems_io_gpios[base+i];
+		if ((NULL == cur) || (NULL == cur->name))
+			continue;
+
+		gpio_request(gpio + i, cur->name);
+		if (cur->out)
+			gpio_direction_output(gpio + i, 0);
+		else
+			gpio_direction_input(gpio + i);
+
+		if (0 == cur->export)
+			continue;
+
+		if (0 != gpio_export(gpio + i, false))
+			pr_err("piAx: EMS IO couldn't export GPIO %d on expander %d\n",
+					(gpio + i), cur->expander);
+	}
+
+	return 0;
+}
+
+static int ems_io_gpio_teardown(
+		struct i2c_client *client,
+		int gpio, unsigned ngpio, void *c)
+{
+	int i = 0;
+
+	for (; i < 8; ++i)
+		gpio_free(gpio + i);
+
+	return 0;
+}
+
+static struct pcf857x_platform_data ems_io_pca9672_data[5] = {
+	EMS_IO_GPIO_DEV_DATA(0),
+	EMS_IO_GPIO_DEV_DATA(1),
+	EMS_IO_GPIO_DEV_DATA(2),
+	EMS_IO_GPIO_DEV_DATA(3),
+	EMS_IO_GPIO_DEV_DATA(4),
+};
+
+static struct i2c_board_info pia35x_ems_io_i2c_info[] = {
+	EMS_IO_GPIO_DEV(0x20,  0, EMS_IO_DOUT),
+	EMS_IO_GPIO_DEV(0x21, 21, EMS_IO_DIN1),
+	EMS_IO_GPIO_DEV(0x22, 19, EMS_IO_DIN2),
+	EMS_IO_GPIO_DEV(0x23,  0, EMS_IO_TERM),
+	EMS_IO_GPIO_DEV(0x12, 17, EMS_IO_DISP),
+};
+
+#define GPIO_EMS_IO_RESET    14
+#define GPIO_EMS_IO_DIN1_INT 21
+#define GPIO_EMS_IO_DIN2_INT 19
+#define GPIO_EMS_IO_DISP_INT 17
+#define GPIO_EMS_IO_SPI2_CS0 181
+#define GPIO_EMS_IO_SPI2_CS1 182
+#define GPIO_EMS_IO_SPI2_CS2 12
+static struct gpio pia35x_ems_io_gpios[] = {
+	{ GPIO_EMS_IO_RESET, GPIOF_DIR_OUT | GPIOF_INIT_LOW,
+			"emsio.reset" },
+	{ GPIO_EMS_IO_DIN1_INT, GPIOF_DIR_IN, "emsio.din1_int"  },
+	{ GPIO_EMS_IO_DIN2_INT, GPIOF_DIR_IN, "emsio.din2_int"},
+	{ GPIO_EMS_IO_DISP_INT, GPIOF_DIR_IN, "emsio.disp_int"  },
+	{ GPIO_EMS_IO_SPI2_CS0, GPIOF_DIR_OUT | GPIOF_INIT_HIGH, NULL },
+	{ GPIO_EMS_IO_SPI2_CS1, GPIOF_DIR_OUT | GPIOF_INIT_HIGH, NULL },
+	{ GPIO_EMS_IO_SPI2_CS2, GPIOF_DIR_OUT | GPIOF_INIT_HIGH, NULL },
+};
+
+static void __init pia35x_ems_io_init(void) {
+	unsigned i;
+
+	pr_info("pia35x: Initializing piA-EMS_IO board");
+
+	/* GPIOs */
+	gpio_request_array(pia35x_ems_io_gpios, ARRAY_SIZE(pia35x_ems_io_gpios));
+	usleep_range(4, 10); /* reset must be held for at least 4us */
+	gpio_set_value(GPIO_EMS_IO_RESET, 1);
+
+	for (i = 0; i < ARRAY_SIZE(pia35x_ems_io_gpios); ++i) {
+		if (NULL == pia35x_ems_io_gpios[i].label)
+			continue;
+
+		if (0 != gpio_export(pia35x_ems_io_gpios[i].gpio, false))
+			pr_err("piAx: EMS IO couldn't export %s\n",
+					pia35x_ems_io_gpios[i].label);
+	}
+
+	/* IO expander */
+	i2c_register_board_info(2, pia35x_ems_io_i2c_info,
+			ARRAY_SIZE(pia35x_ems_io_i2c_info));
+
+	/* setup SPI2 GPIO CS */
+	mcspi2_cs_gpios[0] = GPIO_EMS_IO_SPI2_CS0;
+	mcspi2_cs_gpios[1] = GPIO_EMS_IO_SPI2_CS1;
+	mcspi2_cs_gpios[2] = GPIO_EMS_IO_SPI2_CS2;
+	mcspi2_cs_gpios[3] = 0;
+
+	for (i = 132; i <= 138; ++i)
+		set_irq_type(OMAP_GPIO_IRQ(i), IRQ_TYPE_EDGE_FALLING);
+
+	/* SPI */
+	spi_register_board_info(pia35x_ems_io_spi_info,
+			ARRAY_SIZE(pia35x_ems_io_spi_info));
+}
+#else
+static inline void __init pia35x_ems_io_init(void) {
+	pr_error("pia35x: piA-EMS_IO driver PCA9672|MCP2515|MAX3140 missing\n");
+}
+#endif
 
 /** Integrated Devices **/
 #define GPIO_EN_VCC_5V_PER  28    /* expansion supply voltage */
@@ -1760,6 +2019,9 @@ static int __init pia35x_expansion_init(void)
 	} else if (0 == strcmp(expansionboard_name, "pia_io")) {
 		pia35x_ioexp_init();
 		ret++;
+	} else if (0 == strcmp(expansionboard_name, "pia_ems_io")) {
+		pia35x_ems_io_init();
+		ret++;
 	}
 
 	return ret;
diff --git a/arch/arm/mach-omap2/board-omap3beagle.c b/arch/arm/mach-omap2/board-omap3beagle.c
index a90eec7..a5f3c84 100644
--- a/arch/arm/mach-omap2/board-omap3beagle.c
+++ b/arch/arm/mach-omap2/board-omap3beagle.c
@@ -59,7 +59,8 @@
  *	AXBX	= GPIO173, GPIO172, GPIO171: 1 1 1
  *	C1_3	= GPIO173, GPIO172, GPIO171: 1 1 0
  *	C4	= GPIO173, GPIO172, GPIO171: 1 0 1
- *	XM	= GPIO173, GPIO172, GPIO171: 0 0 0
+ *	XMA/XMB = GPIO173, GPIO172, GPIO171: 0 0 0
+ *	XMC = GPIO173, GPIO172, GPIO171: 0 1 0
  */
 enum {
 	OMAP3BEAGLE_BOARD_UNKN = 0,
@@ -67,14 +68,26 @@ enum {
 	OMAP3BEAGLE_BOARD_C1_3,
 	OMAP3BEAGLE_BOARD_C4,
 	OMAP3BEAGLE_BOARD_XM,
+	OMAP3BEAGLE_BOARD_XMC,
 };
 
 static u8 omap3_beagle_version;
 
-static u8 omap3_beagle_get_rev(void)
-{
-	return omap3_beagle_version;
-}
+/*
+ * Board-specific configuration
+ * Defaults to BeagleBoard-xMC
+ */
+static struct {
+	int mmc1_gpio_wp;
+	int usb_pwr_level;
+	int reset_gpio;
+	int usr_button_gpio;
+} beagle_config = {
+	.mmc1_gpio_wp = -EINVAL,
+	.usb_pwr_level = GPIOF_OUT_INIT_LOW,
+	.reset_gpio = 129,
+	.usr_button_gpio = 4,
+};
 
 static void __init omap3_beagle_init_rev(void)
 {
@@ -108,18 +121,32 @@ static void __init omap3_beagle_init_rev(void)
 	case 7:
 		printk(KERN_INFO "OMAP3 Beagle Rev: Ax/Bx\n");
 		omap3_beagle_version = OMAP3BEAGLE_BOARD_AXBX;
+		beagle_config.mmc1_gpio_wp = 29;
+		beagle_config.reset_gpio = 170;
+		beagle_config.usr_button_gpio = 7;
 		break;
 	case 6:
 		printk(KERN_INFO "OMAP3 Beagle Rev: C1/C2/C3\n");
 		omap3_beagle_version = OMAP3BEAGLE_BOARD_C1_3;
+		beagle_config.mmc1_gpio_wp = 23;
+		beagle_config.reset_gpio = 170;
+		beagle_config.usr_button_gpio = 7;
 		break;
 	case 5:
 		printk(KERN_INFO "OMAP3 Beagle Rev: C4\n");
 		omap3_beagle_version = OMAP3BEAGLE_BOARD_C4;
+		beagle_config.mmc1_gpio_wp = 23;
+		beagle_config.reset_gpio = 170;
+		beagle_config.usr_button_gpio = 7;
 		break;
 	case 0:
-		printk(KERN_INFO "OMAP3 Beagle Rev: xM\n");
+		printk(KERN_INFO "OMAP3 Beagle Rev: xM Ax/Bx\n");
 		omap3_beagle_version = OMAP3BEAGLE_BOARD_XM;
+		beagle_config.usb_pwr_level = GPIOF_OUT_INIT_HIGH;
+		break;
+	case 2:
+		printk(KERN_INFO "OMAP3 Beagle Rev: xM C\n");
+		omap3_beagle_version = OMAP3BEAGLE_BOARD_XMC;
 		break;
 	default:
 		printk(KERN_INFO "OMAP3 Beagle Rev: unknown %hd\n", beagle_rev);
@@ -247,7 +274,7 @@ static struct omap2_hsmmc_info mmc[] = {
 	{
 		.mmc		= 1,
 		.caps		= MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA,
-		.gpio_wp	= 29,
+		.gpio_wp	= -EINVAL,
 	},
 	{}	/* Terminator */
 };
@@ -273,15 +300,12 @@ static struct gpio_led gpio_leds[];
 static int beagle_twl_gpio_setup(struct device *dev,
 		unsigned gpio, unsigned ngpio)
 {
-	if (omap3_beagle_get_rev() == OMAP3BEAGLE_BOARD_XM) {
-		mmc[0].gpio_wp = -EINVAL;
-	} else if ((omap3_beagle_get_rev() == OMAP3BEAGLE_BOARD_C1_3) ||
-		(omap3_beagle_get_rev() == OMAP3BEAGLE_BOARD_C4)) {
-		omap_mux_init_gpio(23, OMAP_PIN_INPUT);
-		mmc[0].gpio_wp = 23;
-	} else {
-		omap_mux_init_gpio(29, OMAP_PIN_INPUT);
-	}
+	int r;
+
+	if (beagle_config.mmc1_gpio_wp != -EINVAL)
+		omap_mux_init_gpio(beagle_config.mmc1_gpio_wp, OMAP_PIN_INPUT);
+	mmc[0].gpio_wp = beagle_config.mmc1_gpio_wp;
+
 	/* gpio + 0 is "mmc0_cd" (input/IRQ) */
 	mmc[0].gpio_cd = gpio + 0;
 	omap2_hsmmc_init(mmc);
@@ -290,63 +314,46 @@ static int beagle_twl_gpio_setup(struct device *dev,
 	beagle_vmmc1_supply.dev = mmc[0].dev;
 	beagle_vsim_supply.dev = mmc[0].dev;
 
-	/* REVISIT: need ehci-omap hooks for external VBUS
-	 * power switch and overcurrent detect
-	 */
-	if (omap3_beagle_get_rev() != OMAP3BEAGLE_BOARD_XM) {
-		gpio_request(gpio + 1, "EHCI_nOC");
-		gpio_direction_input(gpio + 1);
-	}
-
 	/*
 	 * TWL4030_GPIO_MAX + 0 == ledA, EHCI nEN_USB_PWR (out, XM active
 	 * high / others active low)
+	 * DVI reset GPIO is different between beagle revisions
 	 */
-	gpio_request(gpio + TWL4030_GPIO_MAX, "nEN_USB_PWR");
-	gpio_direction_output(gpio + TWL4030_GPIO_MAX, 0);
-	if (omap3_beagle_get_rev() == OMAP3BEAGLE_BOARD_XM)
-		gpio_direction_output(gpio + TWL4030_GPIO_MAX, 1);
-	else
-		gpio_direction_output(gpio + TWL4030_GPIO_MAX, 0);
-
-	/* DVI reset GPIO is different between beagle revisions */
-	if (omap3_beagle_get_rev() == OMAP3BEAGLE_BOARD_XM)
-		beagle_dvi_device.reset_gpio = 129;
-	else
-		beagle_dvi_device.reset_gpio = 170;
-
-	if (omap3_beagle_get_rev() == OMAP3BEAGLE_BOARD_XM) {
-		/* Power on camera interface */
-		gpio_request(gpio + 2, "CAM_EN");
-		gpio_direction_output(gpio + 2, 1);
-
-		/* TWL4030_GPIO_MAX + 0 == ledA, EHCI nEN_USB_PWR (out, active low) */
-		gpio_request(gpio + TWL4030_GPIO_MAX, "nEN_USB_PWR");
-		gpio_direction_output(gpio + TWL4030_GPIO_MAX, 1);
+	/* Valid for all -xM revisions */
+	if (cpu_is_omap3630()) {
+		/*
+		 * gpio + 1 on Xm controls the TFP410's enable line (active
+		 * low)
+		 * gpio + 2 control varies depending on the board rev as below:
+		 * P7/P8 revisions(prototype): Camera EN
+		 * A2+ revisions (production): LDO (DVI, serial, led blocks)
+		 */
+		r = gpio_request_one(gpio + 1,
+				GPIOF_OUT_INIT_LOW, "nDVI_PWR_EN");
+		if (r)
+			pr_err("%s: unable to configure nDVI_PWR_EN\n",
+					__func__);
+		r = gpio_request_one(gpio + 2, GPIOF_OUT_INIT_HIGH,
+				"DVI_LDO_EN");
+		if (r)
+			pr_err("%s: unable to configure DVI_LDO_EN\n",
+					__func__);
 	} else {
-		gpio_request(gpio + 1, "EHCI_nOC");
-		gpio_direction_input(gpio + 1);
-
-		/* TWL4030_GPIO_MAX + 0 == ledA, EHCI nEN_USB_PWR (out, active low) */
-		gpio_request(gpio + TWL4030_GPIO_MAX, "nEN_USB_PWR");
-		gpio_direction_output(gpio + TWL4030_GPIO_MAX, 0);
+		/*
+		 * REVISIT: need ehci-omap hooks for external VBUS
+		 * power switch and overcurrent detect
+		 */
+		if (gpio_request_one(gpio + 1, GPIOF_IN, "EHCI_nOC"))
+			pr_err("%s: unable to configure EHCI_nOC\n", __func__);
 	}
+	beagle_dvi_device.reset_gpio = beagle_config.reset_gpio;
+
+	gpio_request_one(gpio + TWL4030_GPIO_MAX, beagle_config.usb_pwr_level,
+			"nEN_USB_PWR");
+
 	/* TWL4030_GPIO_MAX + 1 == ledB, PMU_STAT (out, active low LED) */
 	gpio_leds[2].gpio = gpio + TWL4030_GPIO_MAX + 1;
 
-	/*
-	 * gpio + 1 on Xm controls the TFP410's enable line (active low)
-	 * gpio + 2 control varies depending on the board rev as follows:
-	 * P7/P8 revisions(prototype): Camera EN
-	 * A2+ revisions (production): LDO (supplies DVI, serial, led blocks)
-	 */
-	if (omap3_beagle_get_rev() == OMAP3BEAGLE_BOARD_XM) {
-		gpio_request(gpio + 1, "nDVI_PWR_EN");
-		gpio_direction_output(gpio + 1, 0);
-		gpio_request(gpio + 2, "DVI_LDO_EN");
-		gpio_direction_output(gpio + 2, 1);
-	}
-
 	return 0;
 }
 
@@ -543,7 +550,8 @@ static struct platform_device leds_gpio = {
 static struct gpio_keys_button gpio_buttons[] = {
 	{
 		.code			= BTN_EXTRA,
-		.gpio			= 7,
+		/* Dynamically assigned depending on board */
+		.gpio			= -EINVAL,
 		.desc			= "user",
 		.wakeup			= 1,
 	},
@@ -644,6 +652,9 @@ static void __init omap3_beagle_init(void)
 	omap3_mux_init(board_mux, OMAP_PACKAGE_CBB);
 	omap3_beagle_init_rev();
 	omap3_beagle_i2c_init();
+
+	gpio_buttons[0].gpio = beagle_config.usr_button_gpio;
+
 	platform_add_devices(omap3_beagle_devices,
 			ARRAY_SIZE(omap3_beagle_devices));
 	omap_serial_init();
diff --git a/arch/arm/mach-omap2/board-omap3evm.c b/arch/arm/mach-omap2/board-omap3evm.c
index f4363e0..3c2cc33 100644
--- a/arch/arm/mach-omap2/board-omap3evm.c
+++ b/arch/arm/mach-omap2/board-omap3evm.c
@@ -284,6 +284,19 @@ static int omap3_evm_enable_lcd(struct omap_dss_device *dssdev)
 	}
 	gpio_set_value(OMAP3EVM_LCD_PANEL_ENVDD, 0);
 
+	/* AM/DM37x: To get DSS working with 75MHz, we must use sys_bootx
+	 * pins for DSS, but since thes GPIO pins are reuired for LCD
+	 * orientation we must change the mux configuration to GPIO[2-3] for
+	 * SYS_BOOT[0-1]
+	 */
+	if (cpu_is_omap3630()) {
+		omap_mux_set_gpio(OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT, 2);
+		omap_mux_set_gpio(OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT, 3);
+
+		gpio_direction_output(OMAP3EVM_LCD_PANEL_LR, 1);
+		gpio_direction_output(OMAP3EVM_LCD_PANEL_UD, 1);
+	}
+
 	if (get_omap3_evm_rev() >= OMAP3EVM_BOARD_GEN_2)
 		gpio_set_value_cansleep(OMAP3EVM_LCD_PANEL_BKLIGHT_GPIO, 0);
 	else
@@ -351,6 +364,17 @@ static int omap3_evm_enable_dvi(struct omap_dss_device *dssdev)
 	}
 
 	gpio_set_value_cansleep(OMAP3EVM_DVI_PANEL_EN_GPIO, 1);
+
+	/* AM/DM37x: To get DSS working with 75MHz, we must use sys_bootx
+	 * pins for DSS, but since thes GPIO pins are reuired for LCD
+	 * orientation we must change the mux configuration to GPIO[2-3] for
+	 * SYS_BOOT[0-1]
+	 */
+	if (cpu_is_omap3630()) {
+		omap_mux_set_gpio(OMAP_MUX_MODE3, 2);
+		omap_mux_set_gpio(OMAP_MUX_MODE3, 3);
+	}
+
 	omap_pm_set_min_bus_tput(&dssdev->dev, OCP_INITIATOR_AGENT, 400000);
 
 	dvi_enabled = 1;
@@ -533,6 +557,109 @@ static struct twl4030_usb_data omap3evm_usb_data = {
 	.usb_mode	= T2_USB_MODE_ULPI,
 };
 
+/**
+ * Macro to configure resources
+ */
+#define TWL4030_RESCONFIG(res,grp,typ1,typ2,state)	\
+	{						\
+		.resource	= res,			\
+		.devgroup	= grp,			\
+		.type		= typ1,			\
+		.type2		= typ2,			\
+		.remap_sleep	= state			\
+	}
+
+static struct twl4030_resconfig  __initdata board_twl4030_rconfig[] = {
+	TWL4030_RESCONFIG(RES_VPLL1, DEV_GRP_P1, 3, 1, RES_STATE_OFF),		/* ? */
+	TWL4030_RESCONFIG(RES_VINTANA1, DEV_GRP_ALL, 1, 2, RES_STATE_SLEEP),
+	TWL4030_RESCONFIG(RES_VINTANA2, DEV_GRP_ALL, 0, 2, RES_STATE_SLEEP),
+	TWL4030_RESCONFIG(RES_VINTDIG, DEV_GRP_ALL, 1, 2, RES_STATE_SLEEP),
+	TWL4030_RESCONFIG(RES_VIO, DEV_GRP_ALL, 2, 2, RES_STATE_SLEEP),
+	TWL4030_RESCONFIG(RES_VDD1, DEV_GRP_P1, 4, 1, RES_STATE_OFF),		/* ? */
+	TWL4030_RESCONFIG(RES_VDD2, DEV_GRP_P1, 3, 1, RES_STATE_OFF),		/* ? */
+	TWL4030_RESCONFIG(RES_REGEN, DEV_GRP_ALL, 2, 1, RES_STATE_SLEEP),
+	TWL4030_RESCONFIG(RES_NRES_PWRON, DEV_GRP_ALL, 0, 1, RES_STATE_SLEEP),
+	TWL4030_RESCONFIG(RES_CLKEN, DEV_GRP_ALL, 3, 2, RES_STATE_SLEEP),
+	TWL4030_RESCONFIG(RES_SYSEN, DEV_GRP_ALL, 6, 1, RES_STATE_SLEEP),
+	TWL4030_RESCONFIG(RES_HFCLKOUT, DEV_GRP_P3, 0, 2, RES_STATE_SLEEP),	/* ? */
+	TWL4030_RESCONFIG(0, 0, 0, 0, 0),
+};
+
+/**
+ * Optimized 'Active to Sleep' sequence
+ */
+static struct twl4030_ins omap3evm_sleep_seq[] __initdata = {
+	{ MSG_SINGULAR(DEV_GRP_NULL, RES_HFCLKOUT, RES_STATE_SLEEP), 20},
+	{ MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R1, RES_STATE_SLEEP), 2 },
+	{ MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2, RES_STATE_SLEEP), 2 },
+};
+
+static struct twl4030_script omap3evm_sleep_script __initdata = {
+	.script	= omap3evm_sleep_seq,
+	.size	= ARRAY_SIZE(omap3evm_sleep_seq),
+	.flags	= TWL4030_SLEEP_SCRIPT,
+};
+
+/**
+ * Optimized 'Sleep to Active (P12)' sequence
+ */
+static struct twl4030_ins omap3evm_wake_p12_seq[] __initdata = {
+	{ MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R1, RES_STATE_ACTIVE), 2 }
+};
+
+static struct twl4030_script omap3evm_wake_p12_script __initdata = {
+	.script = omap3evm_wake_p12_seq,
+	.size   = ARRAY_SIZE(omap3evm_wake_p12_seq),
+	.flags  = TWL4030_WAKEUP12_SCRIPT,
+};
+
+/**
+ * Optimized 'Sleep to Active' (P3) sequence
+ */
+static struct twl4030_ins omap3evm_wake_p3_seq[] __initdata = {
+	{ MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2, RES_STATE_ACTIVE), 2 }
+};
+
+static struct twl4030_script omap3evm_wake_p3_script __initdata = {
+	.script = omap3evm_wake_p3_seq,
+	.size   = ARRAY_SIZE(omap3evm_wake_p3_seq),
+	.flags  = TWL4030_WAKEUP3_SCRIPT,
+};
+
+/**
+ * Optimized warm reset sequence (for less power surge)
+ */
+static struct twl4030_ins omap3evm_wrst_seq[] __initdata = {
+	{ MSG_SINGULAR(DEV_GRP_NULL, RES_RESET, RES_STATE_OFF), 0x2 },
+	{ MSG_SINGULAR(DEV_GRP_NULL, RES_MAIN_REF, RES_STATE_WRST), 2 },
+	{ MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2, RES_STATE_WRST), 0x2},
+	{ MSG_SINGULAR(DEV_GRP_NULL, RES_VUSB_3V1, RES_STATE_WRST), 0x2 },
+	{ MSG_SINGULAR(DEV_GRP_NULL, RES_VPLL1, RES_STATE_WRST), 0x2 },
+	{ MSG_SINGULAR(DEV_GRP_NULL, RES_VDD2, RES_STATE_WRST), 0x7 },
+	{ MSG_SINGULAR(DEV_GRP_NULL, RES_VDD1, RES_STATE_WRST), 0x25 },
+	{ MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_RC, RES_TYPE_ALL, RES_TYPE2_R0, RES_STATE_WRST), 0x2 },
+	{ MSG_SINGULAR(DEV_GRP_NULL, RES_RESET, RES_STATE_ACTIVE), 0x2 },
+};
+
+static struct twl4030_script omap3evm_wrst_script __initdata = {
+	.script = omap3evm_wrst_seq,
+	.size   = ARRAY_SIZE(omap3evm_wrst_seq),
+	.flags  = TWL4030_WRST_SCRIPT,
+};
+
+static struct twl4030_script __initdata *board_twl4030_scripts[] = {
+	&omap3evm_wake_p12_script,
+	&omap3evm_wake_p3_script,
+	&omap3evm_sleep_script,
+	&omap3evm_wrst_script
+};
+
+static struct twl4030_power_data __initdata omap3evm_script_data = {
+	.scripts		= board_twl4030_scripts,
+	.num			= ARRAY_SIZE(board_twl4030_scripts),
+	.resource_config	= board_twl4030_rconfig,
+};
+
 static uint32_t board_keymap[] = {
 	KEY(0, 0, KEY_LEFT),
 	KEY(0, 1, KEY_DOWN),
@@ -625,8 +752,8 @@ static struct regulator_consumer_supply omap3evm_vaux2_supplies = {
 
 static struct regulator_init_data omap3evm_vaux2 = {
 	.constraints = {
-		.min_uV		= 2800000,
-		.max_uV		= 2800000,
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
 		.apply_uV	= true,
 		.valid_modes_mask	= REGULATOR_MODE_NORMAL
 					| REGULATOR_MODE_STANDBY,
@@ -692,6 +819,7 @@ static struct twl4030_platform_data omap3evm_twldata = {
 	.vaux2          = &omap3evm_vaux2,
 	.vio		= &omap3_evm_vio,
 	.vaux3		= &omap3evm_vaux3,
+	.power		= &omap3evm_script_data,
 };
 
 static struct i2c_board_info __initdata omap3evm_i2c_boardinfo[] = {
@@ -925,11 +1053,11 @@ static struct omap_musb_board_data musb_board_data = {
  */
 static void __init omap3_evm_pm_init(void)
 {
-	/* Don't use sys_offmode signal */
-	omap_pm_sys_offmode_select(0);
+	/* Use sys_offmode signal */
+	omap_pm_sys_offmode_select(1);
 
-	/* sys_clkreq - active low */
-	omap_pm_sys_clkreq_pol(0);
+	/* sys_clkreq - active high */
+	omap_pm_sys_clkreq_pol(1);
 
 	/* sys_offmode - active low */
 	omap_pm_sys_offmode_pol(0);
diff --git a/arch/arm/mach-omap2/board-rx51-peripherals.c b/arch/arm/mach-omap2/board-rx51-peripherals.c
index e75e240..a743633 100644
--- a/arch/arm/mach-omap2/board-rx51-peripherals.c
+++ b/arch/arm/mach-omap2/board-rx51-peripherals.c
@@ -687,7 +687,7 @@ static struct twl4030_resconfig twl4030_rconfig[] __initdata = {
 	{ .resource = RES_RESET, .devgroup = -1,
 	  .type = 1, .type2 = -1, .remap_off = -1, .remap_sleep = -1
 	},
-	{ .resource = RES_Main_Ref, .devgroup = -1,
+	{ .resource = RES_MAIN_REF, .devgroup = -1,
 	  .type = 1, .type2 = -1, .remap_off = -1, .remap_sleep = -1
 	},
 	{ 0, 0},
diff --git a/arch/arm/mach-omap2/clockdomains2xxx_3xxx_data.c b/arch/arm/mach-omap2/clockdomains2xxx_3xxx_data.c
index bea7e2c..4e70caa 100644
--- a/arch/arm/mach-omap2/clockdomains2xxx_3xxx_data.c
+++ b/arch/arm/mach-omap2/clockdomains2xxx_3xxx_data.c
@@ -229,31 +229,6 @@ static struct clkdm_dep per_wkdeps[] = {
 	{ NULL },
 };
 
-/* 3430ES2: PM_WKDEP_USBHOST: CORE, IVA2, MPU, WKUP */
-static struct clkdm_dep usbhost_wkdeps[] = {
-	{
-		.clkdm_name = "core_l3_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
-	},
-	{
-		.clkdm_name = "core_l4_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
-	},
-	{
-		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
-	},
-	{
-		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
-	},
-	{
-		.clkdm_name = "wkup_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
-	},
-	{ NULL },
-};
-
 /* 3430 PM_WKDEP_MPU: CORE, IVA2, DSS, PER */
 static struct clkdm_dep mpu_3xxx_wkdeps[] = {
 	{
@@ -381,19 +356,6 @@ static struct clkdm_dep per_sleepdeps[] = {
 	{ NULL },
 };
 
-/* 3430ES2: CM_SLEEPDEP_USBHOST: MPU, IVA */
-static struct clkdm_dep usbhost_sleepdeps[] = {
-	{
-		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
-	},
-	{
-		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
-	},
-	{ NULL },
-};
-
 /* 3430: CM_SLEEPDEP_CAM: MPU */
 static struct clkdm_dep cam_sleepdeps[] = {
 	{
@@ -730,8 +692,6 @@ static struct clockdomain usbhost_clkdm = {
 	.name		= "usbhost_clkdm",
 	.pwrdm		= { .name = "usbhost_pwrdm" },
 	.flags		= CLKDM_CAN_HWSUP_SWSUP,
-	.wkdep_srcs	= usbhost_wkdeps,
-	.sleepdep_srcs	= usbhost_sleepdeps,
 	.clktrctrl_mask = OMAP3430ES2_CLKTRCTRL_USBHOST_MASK,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
 };
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index eae4d92..0bc1e8a 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -316,6 +316,20 @@ static inline void omap_init_audio(void) {}
 
 #endif /* defined(CONFIG_SND_SOC) || defined(CONFIG_SND_SOC_MODULE) */
 
+#if defined(CONFIG_TWL4030_SCRIPT) || defined(CONFIG_TWL4030_SCRIPT_MODULE)
+static struct platform_device omap_twl4030_script = {
+	.name	= "twl4030_script",
+	.id	= -1,
+};
+
+static void omap_init_twl4030_script(void)
+{
+	platform_device_register(&omap_twl4030_script);
+}
+#else
+static inline void omap_init_twl4030_script(void) {}
+#endif
+
 #if defined(CONFIG_SPI_OMAP24XX) || defined(CONFIG_SPI_OMAP24XX_MODULE)
 
 #include <plat/mcspi.h>
@@ -335,8 +349,11 @@ static inline void omap_init_audio(void) {}
 #define TI814X_MCSPI3_BASE		0x481A2100
 #define TI814X_MCSPI4_BASE		0x481A4100
 
+/* HACK CS GPIOs */
+//extern int mcspi1_cs_gpios[4];
 static struct omap2_mcspi_platform_config omap2_mcspi1_config = {
 	.num_cs		= 4,
+	//.cs_gpios	= mcspi1_cs_gpios,
 };
 
 static struct resource omap2_mcspi1_resources[] = {
@@ -357,8 +374,11 @@ static struct platform_device omap2_mcspi1 = {
 	},
 };
 
+/* HACK CS GPIOs */
+extern int mcspi2_cs_gpios[4];
 static struct omap2_mcspi_platform_config omap2_mcspi2_config = {
-	.num_cs		= 2,
+	.num_cs		= 4,
+	.cs_gpios	= mcspi2_cs_gpios,
 };
 
 static struct resource omap2_mcspi2_resources[] = {
@@ -2010,6 +2030,7 @@ static int __init omap2_init_devices(void)
 	omap_init_sham();
 	omap_init_aes();
 	omap_init_vout();
+	omap_init_twl4030_script();
 #ifdef CONFIG_ARCH_TI81XX
 	ti81xx_ethernet_init();
 	ti816x_init_pcie();
diff --git a/arch/arm/mach-omap2/pm.c b/arch/arm/mach-omap2/pm.c
index f7e4d1b..a0d6193 100644
--- a/arch/arm/mach-omap2/pm.c
+++ b/arch/arm/mach-omap2/pm.c
@@ -25,6 +25,7 @@
 #include "clockdomain.h"
 #include "cm-regbits-34xx.h"
 #include "cm2xxx_3xxx.h"
+#include "clock.h"
 #include "pm.h"
 
 static struct omap_device_pm_latency *pm_lats;
@@ -106,7 +107,7 @@ static int _init_omap_device(char *name, struct device **new_dev)
 
 static unsigned long omap3_mpu_get_rate(struct device *dev)
 {
-	return dpll1_clk->rate;
+	return omap2_get_dpll_rate(dpll1_clk);
 }
 
 static int omap3_mpu_set_rate(struct device *dev, unsigned long rate)
@@ -133,9 +134,7 @@ static int omap3_mpu_set_rate(struct device *dev, unsigned long rate)
 #ifdef CONFIG_CPU_FREQ
 	/* Send a post notification to CPUFreq */
 	cpufreq_notify_transition(&freqs_notify, CPUFREQ_POSTCHANGE);
-#endif
-
-#ifndef CONFIG_CPU_FREQ
+#else
 	/*Update loops_per_jiffy if processor speed is being changed*/
 	loops_per_jiffy = compute_lpj(loops_per_jiffy,
 			cur_rate / 1000, rate / 1000);
diff --git a/arch/arm/mach-omap2/powerdomains3xxx_data.c b/arch/arm/mach-omap2/powerdomains3xxx_data.c
index cef8597..fcb6479 100644
--- a/arch/arm/mach-omap2/powerdomains3xxx_data.c
+++ b/arch/arm/mach-omap2/powerdomains3xxx_data.c
@@ -217,7 +217,7 @@ static struct powerdomain usbhost_pwrdm = {
 	 * driver is not selected in kernel config so putting this flag within
 	 * EHCI driver config.
 	 */
-#if 0 /* defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE) */
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
 	.flags	  = PWRDM_HAS_HDWR_SAR, /* for USBHOST ctrlr only */
 #endif
 	.banks		  = 1,
diff --git a/arch/arm/mach-omap2/serial.c b/arch/arm/mach-omap2/serial.c
index 605bdeb..3f71d4d 100644
--- a/arch/arm/mach-omap2/serial.c
+++ b/arch/arm/mach-omap2/serial.c
@@ -369,11 +369,6 @@ static void omap_uart_block_sleep(struct omap_uart_state *uart)
 
 static void omap_uart_allow_sleep(struct omap_uart_state *uart)
 {
-	if (device_may_wakeup(&uart->pdev->dev))
-		omap_uart_enable_wakeup(uart);
-	else
-		omap_uart_disable_wakeup(uart);
-
 	if (!uart->clocked)
 		return;
 
@@ -395,6 +390,11 @@ void omap_uart_prepare_idle(int num)
 
 	list_for_each_entry(uart, &uart_list, node) {
 		if (num == uart->num && uart->can_sleep) {
+			if (device_may_wakeup(&uart->pdev->dev))
+				omap_uart_enable_wakeup(uart);
+			else
+				omap_uart_disable_wakeup(uart);
+
 			omap_uart_disable_clocks(uart);
 			return;
 		}
diff --git a/arch/arm/plat-omap/include/plat/mcspi.h b/arch/arm/plat-omap/include/plat/mcspi.h
index 1254e49..cac1d84 100644
--- a/arch/arm/plat-omap/include/plat/mcspi.h
+++ b/arch/arm/plat-omap/include/plat/mcspi.h
@@ -2,7 +2,8 @@
 #define _OMAP2_MCSPI_H
 
 struct omap2_mcspi_platform_config {
-	unsigned short	num_cs;
+	unsigned short num_cs;
+	int *cs_gpios;
 };
 
 struct omap2_mcspi_device_config {
diff --git a/arch/arm/plat-omap/omap_device.c b/arch/arm/plat-omap/omap_device.c
index 458d648..495ac6d 100644
--- a/arch/arm/plat-omap/omap_device.c
+++ b/arch/arm/plat-omap/omap_device.c
@@ -145,12 +145,12 @@ static int _omap_device_activate(struct omap_device *od, u8 ignore_lat)
 			odpl->activate_lat_worst = act_lat;
 			if (odpl->flags & OMAP_DEVICE_LATENCY_AUTO_ADJUST) {
 				odpl->activate_lat = act_lat;
-				pr_warning("omap_device: %s.%d: new worst case "
+				pr_debug("omap_device: %s.%d: new worst case "
 					   "activate latency %d: %llu\n",
 					   od->pdev.name, od->pdev.id,
 					   od->pm_lat_level, act_lat);
 			} else
-				pr_warning("omap_device: %s.%d: activate "
+				pr_debug("omap_device: %s.%d: activate "
 					   "latency %d higher than exptected. "
 					   "(%llu > %d)\n",
 					   od->pdev.name, od->pdev.id,
@@ -213,12 +213,12 @@ static int _omap_device_deactivate(struct omap_device *od, u8 ignore_lat)
 			odpl->deactivate_lat_worst = deact_lat;
 			if (odpl->flags & OMAP_DEVICE_LATENCY_AUTO_ADJUST) {
 				odpl->deactivate_lat = deact_lat;
-				pr_warning("omap_device: %s.%d: new worst case "
+				pr_debug("omap_device: %s.%d: new worst case "
 					   "deactivate latency %d: %llu\n",
 					   od->pdev.name, od->pdev.id,
 					   od->pm_lat_level, deact_lat);
 			} else
-				pr_warning("omap_device: %s.%d: deactivate "
+				pr_debug("omap_device: %s.%d: deactivate "
 					   "latency %d higher than exptected. "
 					   "(%llu > %d)\n",
 					   od->pdev.name, od->pdev.id,
diff --git a/drivers/media/video/omap/omap_vout.c b/drivers/media/video/omap/omap_vout.c
index 2aee372..88271e4 100644
--- a/drivers/media/video/omap/omap_vout.c
+++ b/drivers/media/video/omap/omap_vout.c
@@ -628,7 +628,7 @@ static int video_mode_to_dss_mode(struct omap_vout_device *vout)
 	struct omap_overlay *ovl;
 	struct omapvideo_info *ovid;
 	struct v4l2_pix_format *pix = &vout->pix;
-	enum omap_color_mode mode;
+	enum omap_color_mode mode = -EINVAL;
 
 	ovid = &vout->vid_info;
 	ovl = ovid->overlays[0];
@@ -1093,7 +1093,7 @@ static int omap_vout_buffer_prepare(struct videobuf_queue *q,
 	if (!rotation_enabled(vout))
 		return 0;
 
-	dmabuf = vout->buf_phy_addr[vb->i];
+	dmabuf = (dma_addr_t) vout->queued_buf_addr[vb->i];
 	/* If rotation is enabled, copy input buffer into VRFB
 	 * memory space using DMA. We are copying input buffer
 	 * into VRFB memory space of desired angle and DSS will
@@ -2497,7 +2497,7 @@ static int omap_vout_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int __init omap_vout_probe(struct platform_device *pdev)
+static int omap_vout_probe(struct platform_device *pdev)
 {
 	int ret = 0, i;
 	struct omap_overlay *ovl;
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index b022c16..089cba3 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -180,6 +180,18 @@ config TWL4030_POWER
 	  and load scripts controling which resources are switched off/on
 	  or reset when a sleep, wakeup or warm reset event occurs.
 
+config TWL4030_SCRIPT
+	tristate "Support TWL4030 script for OMAP3 boards"
+	depends on TWL4030_CORE && TWL4030_POWER
+	default y
+	help
+	  Say yes here if you want to use the twl4030 power scripts
+	  for OMAP3 boards. Power bus message sequence for
+	  TWL4030 to enter sleep/wakeup/warm_reset.
+
+	  TWL4030 power scripts which can be used by different
+	  OMAP3 boards with the power companion chip (TWL4030 series).
+
 config TWL4030_CODEC
 	bool
 	depends on TWL4030_CORE
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index f54b365..64b51a5 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -40,6 +40,7 @@ obj-$(CONFIG_TWL4030_CORE)	+= twl-core.o twl4030-irq.o twl6030-irq.o
 obj-$(CONFIG_TWL4030_POWER)    += twl4030-power.o
 obj-$(CONFIG_TWL4030_CODEC)	+= twl4030-codec.o
 obj-$(CONFIG_TWL6030_PWM)	+= twl6030-pwm.o
+obj-$(CONFIG_TWL4030_SCRIPT)    += twl4030-script-omap.o
 
 obj-$(CONFIG_MFD_MC13XXX)	+= mc13xxx-core.o
 
diff --git a/drivers/mfd/twl-core.c b/drivers/mfd/twl-core.c
index 7c8d5ea..432319f 100644
--- a/drivers/mfd/twl-core.c
+++ b/drivers/mfd/twl-core.c
@@ -229,6 +229,9 @@
 /* is driver active, bound to a chip? */
 static bool inuse;
 
+/* TWL IDCODE Register value */
+static u32 twl_idcode;
+
 static unsigned int twl_id;
 unsigned int twl_rev(void)
 {
@@ -487,6 +490,58 @@ EXPORT_SYMBOL(twl_i2c_read_u8);
 
 /*----------------------------------------------------------------------*/
 
+/**
+ * twl_read_idcode_register - API to read the IDCODE register.
+ *
+ * Unlocks the IDCODE register and read the 32 bit value.
+ */
+static int twl_read_idcode_register(void)
+{
+	int err;
+
+	err = twl_i2c_write_u8(TWL4030_MODULE_INTBR, TWL_EEPROM_R_UNLOCK,
+						REG_UNLOCK_TEST_REG);
+	if (err) {
+		pr_err("TWL4030 Unable to unlock IDCODE registers -%d\n", err);
+		goto fail;
+	}
+
+	err = twl_i2c_read(TWL4030_MODULE_INTBR, (u8 *)(&twl_idcode),
+						REG_IDCODE_7_0, 4);
+	if (err) {
+		pr_err("TWL4030: unable to read IDCODE -%d\n", err);
+		goto fail;
+	}
+
+	err = twl_i2c_write_u8(TWL4030_MODULE_INTBR, 0x0, REG_UNLOCK_TEST_REG);
+	if (err)
+		pr_err("TWL4030 Unable to relock IDCODE registers -%d\n", err);
+fail:
+	return err;
+}
+
+/**
+ * twl_get_type - API to get TWL Si type.
+ *
+ * Api to get the TWL Si type from IDCODE value.
+ */
+int twl_get_type(void)
+{
+	return TWL_SIL_TYPE(twl_idcode);
+}
+EXPORT_SYMBOL_GPL(twl_get_type);
+
+/**
+ * twl_get_version - API to get TWL Si version.
+ *
+ * Api to get the TWL Si version from IDCODE value.
+ */
+int twl_get_version(void)
+{
+	return TWL_SIL_REV(twl_idcode);
+}
+EXPORT_SYMBOL_GPL(twl_get_version);
+
 static struct device *
 add_numbered_child(unsigned chip, const char *name, int num,
 		void *pdata, unsigned pdata_len,
@@ -1007,13 +1062,14 @@ static void usb_gpio_settings(void)
 }
 
 /* NOTE:  this driver only handles a single twl4030/tps659x0 chip */
-static int __init
+static int __devinit
 twl_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	int				status;
 	unsigned			i;
 	struct twl4030_platform_data	*pdata = client->dev.platform_data;
 	u8 temp;
+	int ret = 0;
 
 	if (!pdata) {
 		dev_dbg(&client->dev, "no platform data?\n");
@@ -1060,6 +1116,12 @@ twl_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	/* setup clock framework */
 	clocks_init(&client->dev, pdata->clock);
 
+	/* read TWL IDCODE Register */
+	if (twl_id == TWL4030_CLASS_ID) {
+		ret = twl_read_idcode_register();
+		WARN(ret < 0, "Error: reading twl_idcode register value\n");
+	}
+
 	/* load power event scripts */
 	if (twl_has_power()) {
 		twl4030_power_sr_init();
diff --git a/drivers/mfd/twl4030-power.c b/drivers/mfd/twl4030-power.c
index 1a37ea7..77ff02d1 100644
--- a/drivers/mfd/twl4030-power.c
+++ b/drivers/mfd/twl4030-power.c
@@ -69,6 +69,14 @@ static u8 twl4030_start_script_address = 0x2b;
 #define R_DCDC_GLOBAL_CFG     PHY_TO_OFF_PM_RECEIVER(0x61)
 #define CFG_ENABLE_SRFLX      0x08
 
+#define R_VDD1_OSC		0x5C
+#define R_VDD2_OSC		0x6A
+#define R_VIO_OSC		0x52
+#define EXT_FS_CLK_EN		BIT(6)
+
+#define R_WDT_CFG		0x03
+#define WDT_WRK_TIMEOUT		0x03
+
 /* resource configuration registers
    <RESOURCE>_DEV_GRP   at address 'n+0'
    <RESOURCE>_TYPE      at address 'n+1'
@@ -126,10 +134,10 @@ static u8 res_config_addrs[] = {
 	[RES_HFCLKOUT]	= 0x8b,
 	[RES_32KCLKOUT]	= 0x8e,
 	[RES_RESET]	= 0x91,
-	[RES_Main_Ref]	= 0x94,
+	[RES_MAIN_REF]	= 0x94,
 };
 
-static int __init twl4030_write_script_byte(u8 address, u8 byte)
+static int twl4030_write_script_byte(u8 address, u8 byte)
 {
 	int err;
 
@@ -143,7 +151,7 @@ out:
 	return err;
 }
 
-static int __init twl4030_write_script_ins(u8 address, u16 pmb_message,
+static int twl4030_write_script_ins(u8 address, u16 pmb_message,
 					   u8 delay, u8 next)
 {
 	int err;
@@ -163,7 +171,7 @@ out:
 	return err;
 }
 
-static int __init twl4030_write_script(u8 address, struct twl4030_ins *script,
+static int twl4030_write_script(u8 address, struct twl4030_ins *script,
 				       int len)
 {
 	int err;
@@ -188,7 +196,7 @@ static int __init twl4030_write_script(u8 address, struct twl4030_ins *script,
 	return err;
 }
 
-static int __init twl4030_config_wakeup3_sequence(u8 address)
+static int twl4030_config_wakeup3_sequence(u8 address)
 {
 	int err;
 	u8 data;
@@ -213,7 +221,7 @@ out:
 	return err;
 }
 
-static int __init twl4030_config_wakeup12_sequence(u8 address)
+static int twl4030_config_wakeup12_sequence(u8 address)
 {
 	int err = 0;
 	u8 data;
@@ -267,7 +275,7 @@ out:
 	return err;
 }
 
-static int __init twl4030_config_sleep_sequence(u8 address)
+static int twl4030_config_sleep_sequence(u8 address)
 {
 	int err;
 
@@ -281,7 +289,7 @@ static int __init twl4030_config_sleep_sequence(u8 address)
 	return err;
 }
 
-static int __init twl4030_config_warmreset_sequence(u8 address)
+static int twl4030_config_warmreset_sequence(u8 address)
 {
 	int err;
 	u8 rd_data;
@@ -329,13 +337,13 @@ out:
 	return err;
 }
 
-static int __init twl4030_configure_resource(struct twl4030_resconfig *rconfig)
+static int twl4030_configure_resource(struct twl4030_resconfig *rconfig)
 {
 	int rconfig_addr;
 	int err;
-	u8 type;
-	u8 grp;
-	u8 remap;
+	u8 type, type_value;
+	u8 grp, grp_value;
+	u8 remap, remap_value;
 
 	if (rconfig->resource > TOTAL_RESOURCES) {
 		pr_err("TWL4030 Resource %d does not exist\n",
@@ -346,82 +354,100 @@ static int __init twl4030_configure_resource(struct twl4030_resconfig *rconfig)
 	rconfig_addr = res_config_addrs[rconfig->resource];
 
 	/* Set resource group */
-	err = twl_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &grp,
+	if (rconfig->devgroup != TWL4030_RESCONFIG_UNDEF) {
+		err = twl_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &grp,
 			      rconfig_addr + DEV_GRP_OFFSET);
-	if (err) {
-		pr_err("TWL4030 Resource %d group could not be read\n",
-			rconfig->resource);
-		return err;
-	}
+		if (err) {
+			pr_err("TWL4030 Resource %d group could not be read\n",
+				rconfig->resource);
+			return err;
+		}
 
-	if (rconfig->devgroup != TWL4030_RESCONFIG_UNDEF) {
-		grp &= ~DEV_GRP_MASK;
-		grp |= rconfig->devgroup << DEV_GRP_SHIFT;
-		err = twl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+		grp_value = (grp & DEV_GRP_MASK) >> DEV_GRP_SHIFT;
+
+		if (rconfig->devgroup != grp_value) {
+			grp &= ~DEV_GRP_MASK;
+			grp |= rconfig->devgroup << DEV_GRP_SHIFT;
+			err = twl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
 				       grp, rconfig_addr + DEV_GRP_OFFSET);
-		if (err < 0) {
-			pr_err("TWL4030 failed to program devgroup\n");
-			return err;
+			if (err < 0) {
+				pr_err("TWL4030 failed to program devgroup\n");
+				return err;
+			}
 		}
 	}
 
 	/* Set resource types */
-	err = twl_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &type,
+	if ((rconfig->type != TWL4030_RESCONFIG_UNDEF) ||
+		(rconfig->type2 != TWL4030_RESCONFIG_UNDEF)) {
+
+		err = twl_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &type,
 				rconfig_addr + TYPE_OFFSET);
-	if (err < 0) {
-		pr_err("TWL4030 Resource %d type could not be read\n",
-			rconfig->resource);
-		return err;
-	}
+		if (err < 0) {
+			pr_err("TWL4030 Resource %d type could not be read\n",
+				rconfig->resource);
+			return err;
+		}
 
-	if (rconfig->type != TWL4030_RESCONFIG_UNDEF) {
-		type &= ~TYPE_MASK;
-		type |= rconfig->type << TYPE_SHIFT;
-	}
+		type_value = type;
 
-	if (rconfig->type2 != TWL4030_RESCONFIG_UNDEF) {
-		type &= ~TYPE2_MASK;
-		type |= rconfig->type2 << TYPE2_SHIFT;
-	}
+		if (rconfig->type != TWL4030_RESCONFIG_UNDEF) {
+			type &= ~TYPE_MASK;
+			type |= rconfig->type << TYPE_SHIFT;
+		}
+
+		if (rconfig->type2 != TWL4030_RESCONFIG_UNDEF) {
+			type &= ~TYPE2_MASK;
+			type |= rconfig->type2 << TYPE2_SHIFT;
+		}
 
-	err = twl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+		if (type != type_value) {
+			err = twl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
 				type, rconfig_addr + TYPE_OFFSET);
-	if (err < 0) {
-		pr_err("TWL4030 failed to program resource type\n");
-		return err;
+			if (err < 0) {
+				pr_err("TWL4030 failed to program resource type\n");
+				return err;
+			}
+		}
 	}
 
 	/* Set remap states */
-	err = twl_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &remap,
+	if ((rconfig->remap_off != TWL4030_RESCONFIG_UNDEF) ||
+		(rconfig->remap_sleep != TWL4030_RESCONFIG_UNDEF)) {
+		err = twl_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &remap,
 			      rconfig_addr + REMAP_OFFSET);
-	if (err < 0) {
-		pr_err("TWL4030 Resource %d remap could not be read\n",
-			rconfig->resource);
-		return err;
-	}
+		if (err < 0) {
+			pr_err("TWL4030 Resource %d remap could not be read\n",
+				rconfig->resource);
+			return err;
+		}
 
-	if (rconfig->remap_off != TWL4030_RESCONFIG_UNDEF) {
-		remap &= ~OFF_STATE_MASK;
-		remap |= rconfig->remap_off << OFF_STATE_SHIFT;
-	}
+		remap_value = remap;
 
-	if (rconfig->remap_sleep != TWL4030_RESCONFIG_UNDEF) {
-		remap &= ~SLEEP_STATE_MASK;
-		remap |= rconfig->remap_sleep << SLEEP_STATE_SHIFT;
-	}
+		if (rconfig->remap_off != TWL4030_RESCONFIG_UNDEF) {
+			remap &= ~OFF_STATE_MASK;
+			remap |= rconfig->remap_off << OFF_STATE_SHIFT;
+		}
 
-	err = twl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
-			       remap,
-			       rconfig_addr + REMAP_OFFSET);
-	if (err < 0) {
-		pr_err("TWL4030 failed to program remap\n");
-		return err;
+		if (rconfig->remap_sleep != TWL4030_RESCONFIG_UNDEF) {
+			remap &= ~SLEEP_STATE_MASK;
+			remap |= rconfig->remap_sleep << SLEEP_STATE_SHIFT;
+		}
+
+		if (remap != remap_value) {
+			err = twl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+			       remap, rconfig_addr + REMAP_OFFSET);
+			if (err < 0) {
+				pr_err("TWL4030 failed to program remap\n");
+				return err;
+			}
+		}
 	}
 
 	return 0;
 }
 
-static int __init load_twl4030_script(struct twl4030_script *tscript,
+static int load_twl4030_script(struct twl4030_script *tscript,
 	       u8 address)
 {
 	int err;
@@ -453,12 +479,13 @@ static int __init load_twl4030_script(struct twl4030_script *tscript,
 		if (err)
 			goto out;
 	}
-	if (tscript->flags & TWL4030_SLEEP_SCRIPT)
-		if (order)
+	if (tscript->flags & TWL4030_SLEEP_SCRIPT) {
+		if (!order)
 			pr_warning("TWL4030: Bad order of scripts (sleep "\
 					"script before wakeup) Leads to boot"\
 					"failure on some boards\n");
 		err = twl4030_config_sleep_sequence(address);
+	}
 out:
 	return err;
 }
@@ -490,9 +517,9 @@ int twl4030_remove_script(u8 flags)
 			return err;
 	}
 	if (flags & TWL4030_WAKEUP12_SCRIPT) {
-		if (err)
 		err = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, END_OF_SCRIPT,
 				R_SEQ_ADD_S2A12);
+		if (err)
 			return err;
 	}
 	if (flags & TWL4030_WAKEUP3_SCRIPT) {
@@ -538,8 +565,128 @@ void __init twl4030_power_sr_init()
 	/* Register the SR init API with the Smartreflex driver */
 	omap_sr_register_pmic(&twl4030_sr_data);
 }
+EXPORT_SYMBOL_GPL(twl4030_remove_script);
+
+/**
+ * twl_dcdc_use_hfclk - API to use HFCLK for TWL DCDCs
+ *
+ * TWL DCDCs switching to HFCLK instead of using internal RC oscillator.
+ */
+static int twl_dcdc_use_hfclk(void)
+{
+	u8 val;
+	u8 smps_osc_reg[] = {R_VDD1_OSC, R_VDD2_OSC, R_VIO_OSC};
+	int i;
+	int err;
+
+	for (i = 0; i < sizeof(smps_osc_reg); i++) {
+		err = twl_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &val,
+							smps_osc_reg[i]);
+		val |= EXT_FS_CLK_EN;
+		err |= twl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, val,
+							smps_osc_reg[i]);
+	}
+	return err;
+}
 
-void __init twl4030_power_init(struct twl4030_power_data *twl4030_scripts)
+/**
+ * twl_erratum27_workaround - Workaround for TWL5030 Silicon Erratum 27
+ * 27 - VDD1, VDD2, may have glitches when their output value is updated.
+ * 28 - VDD1 and / or VDD2 DCDC clock may stop working when internal clock is
+ * switched from internal to external.
+ *
+ * Workaround requires the TWL DCDCs to use HFCLK instead of
+ * internal oscillator. Also enable TWL watchdog before switching the osc
+ * to recover if the VDD1/VDD2 stop working.
+ */
+static void twl_erratum27_workaround(void)
+{
+	u8 wdt_counter_val = 0;
+	int err;
+
+	/* Setup the twl wdt to take care of borderline failure case */
+	err = twl_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &wdt_counter_val,
+			R_WDT_CFG);
+	err |= twl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, WDT_WRK_TIMEOUT,
+			R_WDT_CFG);
+
+	/* TWL DCDC switching to HFCLK */
+	err |= twl_dcdc_use_hfclk();
+
+	/* restore the original value */
+	err |= twl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, wdt_counter_val,
+			R_WDT_CFG);
+	if (err)
+		pr_warning("TWL4030: workaround setup failed!\n");
+}
+
+static bool is_twl5030_erratum27wa_required(void)
+{
+	if (twl_get_type() == TWL_SIL_5030)
+		return (twl_get_version() < TWL5030_REV_1_2);
+
+	return 0;
+}
+
+/**
+ * PMIC initialization specific for the OMAP3EVM
+ */
+static int twl4030_omap3evm_init(void)
+{
+	int err = 0;
+
+	err = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, 0x0A,
+					TWL4030_PM_MASTER_CFG_BOOT);
+
+	if (unlikely(err))
+		pr_err("err: CFG_BOOT\n");
+
+	/* PWR_EDR1 */
+	err = twl_i2c_write_u8(TWL4030_MODULE_INT, 0x00,
+					TWL4030_INT_PWR_EDR1);
+
+	if (unlikely(err))
+		pr_err("err: PWR_EDR1\n");
+
+	/* PWR_EDR2 */
+	err = twl_i2c_write_u8(TWL4030_MODULE_INT, 0x00,
+					TWL4030_INT_PWR_EDR2);
+
+	if (unlikely(err))
+		pr_err("err: PWR_EDR2\n");
+
+	/* PWR_SIH_CTRL */
+	err = twl_i2c_write_u8(TWL4030_MODULE_INT, 0x05,
+					TWL4030_INT_PWR_SIH_CTRL);
+
+	if (unlikely(err))
+		pr_err("err: PWR_EDR2\n");
+
+	/* CFG_P1_TRANSITION */
+	err = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, 0x00,
+					TWL4030_PM_MASTER_CFG_P1_TRANSITION);
+
+	if (unlikely(err))
+		pr_err("err: CFG_P1_TRANSITION\n");
+
+	/* CFG_P2_TRANSITION */
+	err = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, 0x00,
+					TWL4030_PM_MASTER_CFG_P2_TRANSITION);
+
+	if (unlikely(err))
+		pr_err("err: CFG_P2_TRANSITION\n");
+
+	/* CFG_P3_TRANSITION */
+	err = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, 0x00,
+					TWL4030_PM_MASTER_CFG_P3_TRANSITION);
+
+	if (unlikely(err))
+		pr_err("err: CFG_P3_TRANSITION\n");
+
+	return err;
+}
+
+int twl4030_power_init(struct twl4030_power_data *twl4030_scripts)
 {
 	int err = 0;
 	int i;
@@ -558,6 +705,15 @@ void __init twl4030_power_init(struct twl4030_power_data *twl4030_scripts)
 	if (err)
 		goto unlock;
 
+	/* Applying TWL5030 Erratum 27 WA based on Si revision &
+	 * flag updated from board file*/
+	if (is_twl5030_erratum27wa_required()) {
+		pr_info("TWL5030: Enabling workaround for Si Erratum 27\n");
+		twl_erratum27_workaround();
+		if (twl4030_scripts->twl5030_erratum27wa_script)
+			twl4030_scripts->twl5030_erratum27wa_script();
+	}
+
 	for (i = 0; i < twl4030_scripts->num; i++) {
 		err = load_twl4030_script(twl4030_scripts->scripts[i], address);
 		if (err)
@@ -576,22 +732,34 @@ void __init twl4030_power_init(struct twl4030_power_data *twl4030_scripts)
 		}
 	}
 
+	/*
+	 * TODO: Workaround until we get better way to identify that
+	 *       we are running on OMAP3EVM. May not be necessary - but
+	 *       being prudent to ensure we don't break any other board.
+	 */
+	if (machine_is_omap3evm()) {
+		err = twl4030_omap3evm_init() ;
+		if (err)
+			goto unlock;
+	}
+
 	err = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, 0,
 			TWL4030_PM_MASTER_PROTECT_KEY);
 	if (err)
 		pr_err("TWL4030 Unable to relock registers\n");
-	return;
+	return err;
 
 unlock:
 	if (err)
 		pr_err("TWL4030 Unable to unlock registers\n");
-	return;
+	return err;
 load:
 	if (err)
 		pr_err("TWL4030 failed to load scripts\n");
-	return;
+	return err;
 resource:
 	if (err)
 		pr_err("TWL4030 failed to configure resource\n");
-	return;
+	return err;
 }
+EXPORT_SYMBOL_GPL(twl4030_power_init);
diff --git a/drivers/mfd/twl4030-script-omap.c b/drivers/mfd/twl4030-script-omap.c
new file mode 100644
index 0000000..aa982f7
--- /dev/null
+++ b/drivers/mfd/twl4030-script-omap.c
@@ -0,0 +1,525 @@
+/*
+ * OMAP power script for PMIC TWL4030
+ *
+ * Author: Lesly A M <leslyam@ti.com>
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc.
+ * Lesly A M <leslyam@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <linux/i2c/twl.h>
+
+/*
+ * power management signal connections for OMAP3430 with TWL5030
+ *
+ *                          TWL5030                             OMAP3430
+ *                     ______________________             _____________________
+ *                    |                      |           |                     |
+ *                    |          (P1) NSLEEP1|<----------|SYS_OFFMODE          |
+ *                    |              NRESWARM|<----------|NWARMRESET           |
+ *                    |          (P2) NSLEEP2|---|       |                     |
+ *                    |                      |  ===      |                     |
+ *                    |                      |   -       |                     |
+ *                    |                      |           |                     |
+ *                    |                 VDD1 |---------->| VDD1                |
+ *                    |                 VDD2 |---------->| VDD2                |
+ *                    |                  VIO |---------->| VDDS                |
+ *  ________          |                VAUX1 |           |                     |
+ * |        |         |                 ...  |           |                     |
+ * |  ENABLE|<--------|CLKEN           CLKREQ|<----------|SYS_CLKREQ           |
+ * |  CLKOUT|-------->|HFCLKIN  (P3) HFCLKOUT|---------->|XTALIN               |
+ * |________|         |______________________|           |_____________________|
+ *
+ *
+ *	Signal descriptions:
+ *
+ * SYS_OFFMODE - OMAP drives this signal low only when the OMAP is in the
+ *	OFF idle mode. It is driven high when a wake up event is detected.
+ *	This signal should control the P1 device group in the PMIC.
+ *
+ * SYS_CLKREQ - OMAP should drive this signal low when the OMAP goes into
+ *	any idle mode. This signal should control the P3 device group
+ *	in the PMIC. It is used to notify PMIC when XTALIN is no longer needed.
+ *
+ * NSLEEP1(P1) - When this signal goes low the P1 sleep sequence is executed
+ *	in the PMIC turning off certain resources. When this signal goes high
+ *	the P1 active sequence is executed turning back on certain resources.
+ *
+ * NSLEEP2(P2) - This signal controls the P2 device group of the PMIC.
+ *	It is not used in this setup and should be tied to ground.
+ *	This can be used for connecting a different processor or MODEM chip.
+ *
+ * CLKREQ(P3) - When this signal goes low the P3 sleep sequence is executed
+ *	in the PMIC turning off HFCLKOUT. When this signal goes high
+ *	the P3 active sequence is executed turning back on HFCLKOUT and other
+ *	resources.
+ *
+ * CLKEN - Enable signal for oscillator. Should only go low when OMAP is
+ *	in the OFF idle mode due to long oscillator startup times.
+ *
+ * HFCLKIN - Oscillator output clock into PMIC.
+ *
+ * HFCLKOUT - System clock output from PMIC to OMAP.
+ *
+ * XTALIN - OMAP system clock input(HFCLKOUT).
+ */
+
+/*
+ * Recommended sleep and active sequences for TWL5030 when connected to OMAP3
+ *
+ * WARNING: If the board is using NSLEEP2(P2), should modify this script and
+ * setuptime values accordingly.
+ *
+ * Chip Retention/Off (using i2c for scaling voltage):
+ *	When OMAP de-assert the SYS_CLKREQ signal, only HFCLKOUT is affected
+ *	since it is the only resource assigned to P3 only.
+ *
+ * Sysoff (using sys_off signal):
+ *	When OMAP de-assert the SYS_OFFMODE signal A2S(active to sleep sequence)
+ *	on the PMIC is executed. This will put resources of TYPE2=1 and TYPE2=2
+ *	into sleep. At this point only resources assigned to P1 only will be
+ *	affected (VDD1, VDD2 & VPLL1).
+ *
+ *	Next the OMAP will lower SYS_CLKREQ which will allow the A2S sequence
+ *	in PMIC to execute again. This will put resources of TYPE2=1 and TYPE2=2
+ *	into sleep but will affect resources that are assigned to P3(HFCLKOUT)
+ *	only or assigned to P1 and P3.
+ *
+ *	On wakeup event OMAP goes active and pulls the SYS_CLKREQ high,
+ *	which will execute the P3 S2A sequence on the PMIC. This will turn on
+ *	resources assigned to P3 or assigned to P1 and P3 and of TYPE2=2.
+ *
+ *	Next the OMAP will wait the PRM_VOLTOFFSET time and then de-assert
+ *	the SYS_OFFMODE pin allowing the PMIC to execute the P1 S2A active
+ *	sequence. This will turn on resources assigned to P1 or assigned to
+ *	P1 and P3 and of TYPE2=1.
+ *
+ *	Timing diagram for OMAP wakeup from OFFMODE using sys_off signal
+ *                 _____________________________________________________________
+ * OMAP active  __/
+ *                       |<--------------------PRM_CLKSETP-------------------->|
+ *                        ______________________________________________________
+ * SYS_CLKREQ   _________/
+ *                           ___________________________________________________
+ * CLKEN        ____________/
+ *
+ * HFCLKIN      _______________________________________________/////////////////
+ *
+ * HFCLKOUT     __________________________________________________//////////////
+ *                       |<---PRM_VOLTOFFSET-->|
+ *                                              ________________________________
+ * SYS_OFFMODE  _______________________________/
+ *                                             |<--------PRM_VOLTSETUP2------->|
+ *                                                                   ___________
+ * VPLL1        ____________________________________________________/
+ *                                                                            __
+ * VDD1         _____________________________________________________________/
+ *                                                                            __
+ * VDD2         _____________________________________________________________/
+ *
+ *	Other resources which are not handled by this script should be
+ *	controlled by the respective drivers using them (VAUX1, VAUX2, VAUX3,
+ *	VAUX4, VMMC1, VMMC2, VPLL2, VSIM, VDAC, VUSB1V5, VUSB1V8 & VUSB3V1).
+ *
+ * More info:
+ *	http://omapedia.org/wiki/TWL4030_power_scripts
+ */
+
+/**
+ * DOC: Sleep to active sequence for P1/P2
+ *
+ * Sequence to control the TWL4030 Power resources,
+ * when the system wakeup from sleep.
+ * Executed upon P1_P2 transition for wakeup
+ * (sys_offmode signal de-asserted on OMAP).
+ */
+static struct twl4030_ins wakeup_p12_seq[] __initdata = {
+	/*
+	 * Broadcast message to put resources to active
+	 *
+	 * Since we are not using TYPE, resources which have TYPE2 configured
+	 * as 1 will be targeted (VPLL1, VDD1, VDD2, REGEN, NRES_PWRON, SYSEN).
+	 */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R1,
+							RES_STATE_ACTIVE), 2},
+};
+
+static struct twl4030_script wakeup_p12_script __initdata = {
+	.script	= wakeup_p12_seq,
+	.size	= ARRAY_SIZE(wakeup_p12_seq),
+	.flags	= TWL4030_WAKEUP12_SCRIPT,
+};
+
+/**
+ * DOC: Sleep to active sequence for P3
+ *
+ * Sequence to control the TWL4030 Power resources,
+ * when the system wakeup from sleep.
+ * Executed upon P3 transition for wakeup
+ * (clkreq signal asserted on OMAP).
+ */
+static struct twl4030_ins wakeup_p3_seq[] __initdata = {
+	/*
+	 * Broadcast message to put resources to active
+	 *
+	 * Since we are not using TYPE, resources which have TYPE2 configured
+	 * as 2 will be targeted
+	 * (VINTANA1, VINTANA2, VINTDIG, VIO, CLKEN, HFCLKOUT).
+	 */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2,
+							RES_STATE_ACTIVE), 2},
+};
+
+static struct twl4030_script wakeup_p3_script __initdata = {
+	.script = wakeup_p3_seq,
+	.size   = ARRAY_SIZE(wakeup_p3_seq),
+	.flags  = TWL4030_WAKEUP3_SCRIPT,
+};
+
+/**
+ * DOC: Active to sleep sequence for P1/P2/P3
+ *
+ * Sequence to control the TWL4030 Power resources,
+ * when the system goes into sleep.
+ * Executed upon P1_P2/P3 transition for sleep.
+ * (sys_offmode signal asserted/clkreq de-asserted on OMAP).
+ */
+static struct twl4030_ins sleep_on_seq[] __initdata = {
+	/* Broadcast message to put res to sleep (TYPE2 = 1, 2) */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R1,
+							RES_STATE_SLEEP), 2},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2,
+							RES_STATE_SLEEP), 2},
+};
+
+static struct twl4030_script sleep_on_script __initdata = {
+	.script	= sleep_on_seq,
+	.size	= ARRAY_SIZE(sleep_on_seq),
+	.flags	= TWL4030_SLEEP_SCRIPT,
+};
+
+/**
+ * DOC: Warm reset sequence
+ *
+ * Sequence to reset the TWL4030 Power resources,
+ * when the system gets warm reset.
+ * Executed upon warm reset signal.
+ *
+ * First the device is put in reset, then the system clock is requested to
+ * the external oscillator, and default ON power reference and power providers
+ * are enabled. Next some additional resources which are software controlled
+ * are enabled. Finally sequence is ended by the release of TWL5030 reset.
+ */
+static struct twl4030_ins wrst_seq[] __initdata = {
+	/*
+	 * As a workaround for OMAP Erratum  (ID: i537 - OMAP HS devices are
+	 * not recovering from warm reset while in OFF mode)
+	 * NRESPWRON is toggled to force a power on reset condition to OMAP
+	 */
+	/* Trun OFF NRES_PWRON */
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_NRES_PWRON, RES_STATE_OFF), 2},
+	/* Reset twl4030 */
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_RESET, RES_STATE_OFF), 2},
+	/* Reset MAIN_REF */
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_MAIN_REF, RES_STATE_WRST), 2},
+	/* Reset All type2_group2 */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2,
+							RES_STATE_WRST), 2},
+	/* Reset VUSB_3v1 */
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_VUSB_3V1, RES_STATE_WRST), 2},
+	/* Reset All type2_group1 */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R1,
+							RES_STATE_WRST), 2},
+	/* Reset the Reset & Contorl_signals */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_RC, RES_TYPE_ALL, RES_TYPE2_R0,
+							RES_STATE_WRST), 2},
+	/* Re-enable twl4030 */
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_RESET, RES_STATE_ACTIVE), 2},
+	/* Trun ON NRES_PWRON */
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_NRES_PWRON, RES_STATE_ACTIVE), 2},
+};
+
+static struct twl4030_script wrst_script __initdata = {
+	.script = wrst_seq,
+	.size   = ARRAY_SIZE(wrst_seq),
+	.flags  = TWL4030_WRST_SCRIPT,
+};
+
+/* TWL4030 script for sleep, wakeup & warm_reset */
+static struct twl4030_script *twl4030_scripts[] __initdata = {
+	&wakeup_p12_script,
+	&wakeup_p3_script,
+	&sleep_on_script,
+	&wrst_script,
+};
+
+/**
+ * DOC: TWL4030 resource configuration
+ *
+ * Resource which are attached to P1 device group alone
+ * will go to sleep state, when sys_off signal from OMAP is de-asserted.
+ *	(VPLL1, VDD1, VDD2)
+ *
+ * None of the resources are attached to P2 device group alone.
+ * (WARNING: If MODEM or connectivity chip is connected to NSLEEP2 PIN on
+ * TWL4030, should modify the resource configuration accordingly).
+ *
+ * Resource which are attached to P3 device group alone
+ * will go to sleep state, when clk_req signal from OMAP is de-asserted.
+ *	(HFCLKOUT)
+ *
+ * Resource which are attached to more than one device group
+ * will go to sleep state, when corresponding signals are de-asserted.
+ *	(VINTANA1, VINTANA2, VINTDIG, VIO, REGEN, NRESPWRON, CLKEN, SYSEN)
+ *
+ * REGEN is an output of the device which can be connected to slave power ICs
+ * or external LDOs that power on before voltage for the IO interface (VIO).
+ *
+ * SYSEN is a bidirectional signal of the device that controls slave power ICs.
+ * In master mode, the device sets SYSEN high to enable the slave power ICs.
+ * In slave mode, when one of the power ICs drives the SYSEN signal low,
+ * all devices of the platform stay in the wait-on state.
+ *
+ * Resource which are attached to none of the device group by default
+ * will be in sleep state. These resource should be controlled by
+ * the respective drivers using them.
+ * Resource which are controlled by drivers are not modified here.
+ *	(VAUX1, VAUX2, VAUX3, VAUX4, VMMC1, VMMC2, VPLL2, VSIM, VDAC,
+ *	VUSB1V5, VUSB1V8, VUSB3V1)
+ *
+ * Resource using reset values.
+ *	(32KCLKOUT, TRITON_RESET, MAINREF)
+ */
+static struct twl4030_resconfig twl4030_rconfig[] __initdata = {
+	{ .resource = RES_VPLL1, .devgroup = DEV_GRP_P1, .type = 3,
+		.type2 = 1, .remap_sleep = RES_STATE_OFF },
+	{ .resource = RES_VINTANA1, .devgroup = DEV_GRP_ALL, .type = 1,
+		.type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_VINTANA2, .devgroup = DEV_GRP_ALL, .type = 0,
+		.type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_VINTDIG, .devgroup = DEV_GRP_ALL, .type = 1,
+		.type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_VIO, .devgroup = DEV_GRP_ALL, .type = 2,
+		.type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_VDD1, .devgroup = DEV_GRP_P1,
+		.type = 4, .type2 = 1, .remap_sleep = RES_STATE_OFF },
+	{ .resource = RES_VDD2, .devgroup = DEV_GRP_P1,
+		.type = 3, .type2 = 1, .remap_sleep = RES_STATE_OFF },
+	{ .resource = RES_REGEN, .devgroup = DEV_GRP_ALL, .type = 2,
+		.type2 = 1, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_NRES_PWRON, .devgroup = DEV_GRP_ALL, .type = 0,
+		.type2 = 1, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_CLKEN, .devgroup = DEV_GRP_ALL, .type = 3,
+		.type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_SYSEN, .devgroup = DEV_GRP_ALL, .type = 6,
+		.type2 = 1, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_HFCLKOUT, .devgroup = DEV_GRP_P3,
+		.type = 0, .type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ 0, 0},
+};
+
+/*
+ * Sleep and active sequences with changes for TWL5030 Erratum 27 workaround
+ *
+ * Sysoff (using sys_off signal):
+ *	When SYS_CLKREQ goes low during retention no resources will be affected
+ *	since no resources are assigned to P3 only.
+ *
+ *	Since all resources are assigned to P1 and P3 then all resources
+ *	will be affected on the falling edge of P3 (SYS_CLKREQ).
+ *	When OMAP lower the SYS_CLKREQ signal PMIC will execute the
+ *	A2S sequence in which HFCLKOUT is dissabled first and
+ *	after 488.32 usec(PRM_VOLTOFFSET) resources assigned to P1 and P3
+ *	and of TYPE2=1 are put to sleep
+ *	(VDD1, VDD2, VPLL1, REGEN, NRESPWRON & SYSEN).
+ *	Again after a 61.04 usec resources assigned to P1 and P3
+ *	and of TYPE2=2 are put to sleep
+ *	(VINTANA1, VINTANA2, VINTDIG, VIO & CLKEN).
+ *
+ *	On wakeup event OMAP goes active and pulls the SYS_CLKREQ high,
+ *	and will execute the S2A sequence which is same for P1_P2 & P3.
+ *	This will turn on all resources of TYPE2=2 to go to the active state.
+ *	Three dummy broadcast messages are added to get a delay of ~10 ms
+ *	before enabling the HFCLKOUT resource. And after a 30.52 usec
+ *	all resources of TYPE2=1 are put to the active state.
+ *
+ *	This 10ms delay can be reduced if the oscillator is having less
+ *	stabilization time. A should be taken care if it needs more time
+ *	for stabilization.
+ *
+ */
+
+/**
+ * DOC: Sleep to Active sequence for P1/P2/P3
+ *
+ * The wakeup sequence is adjusted to do the VDD1/VDD2 voltage ramp-up
+ * only after HFCLKIN is stabilized and the HFCLKOUT is enabled.
+ */
+static struct twl4030_ins wakeup_seq_erratum27[] __initdata = {
+	/*
+	 * Broadcast message to put res(TYPE2 = 2) to active.
+	 * Wait for ~10 mS (ramp-up time for OSC on the board)
+	 * after HFCLKIN is enabled
+	 */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2,
+							RES_STATE_ACTIVE), 55},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2,
+							RES_STATE_ACTIVE), 55},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2,
+							RES_STATE_ACTIVE), 54},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2,
+							RES_STATE_ACTIVE), 1},
+	/* Singular message to enable HCLKOUT after HFCLKIN is stabilized */
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_HFCLKOUT, RES_STATE_ACTIVE), 1},
+	/*
+	 * Broadcast message to put res(TYPE2 = 1) to active.
+	 * VDD1/VDD2 ramp-up after HFCLKIN is stable and HFCLKOUT is enabled.
+	 */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R1,
+							RES_STATE_ACTIVE), 2},
+};
+
+static struct twl4030_script wakeup_script_erratum27 __initdata = {
+	.script	= wakeup_seq_erratum27,
+	.size	= ARRAY_SIZE(wakeup_seq_erratum27),
+	.flags	= TWL4030_WAKEUP12_SCRIPT | TWL4030_WAKEUP3_SCRIPT,
+};
+
+/**
+ * DOC: Active to Sleep sequence for P1/P2/P3
+ *
+ * The sleep sequence is adjusted to do the switching of VDD1/VDD2/VIO OSC from
+ * HFCLKIN to internal oscillator when the HFCLKIN is stable.
+ */
+static struct twl4030_ins sleep_on_seq_erratum27[] __initdata = {
+	/*
+	 * Singular message to disable HCLKOUT.
+	 * Wait for ~488.32 uS to do the switching of VDD1/VDD2/VIO OSC from
+	 * HFCLKIN to internal oscillator before disabling HFCLKIN.
+	 */
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_HFCLKOUT, RES_STATE_SLEEP), 20},
+	/* Broadcast message to put res(TYPE2 = 1) to sleep */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R1,
+							RES_STATE_SLEEP), 2},
+	/* Broadcast message to put res(TYPE2 = 2) to sleep, disable HFCLKIN */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2,
+							RES_STATE_SLEEP), 2},
+};
+
+static struct twl4030_script sleep_on_script_erratum27 __initdata = {
+	.script	= sleep_on_seq_erratum27,
+	.size	= ARRAY_SIZE(sleep_on_seq_erratum27),
+	.flags	= TWL4030_SLEEP_SCRIPT,
+};
+
+/* TWL4030 script for sleep, wakeup & warm_reset */
+static struct twl4030_script *twl4030_scripts_erratum27[] __initdata = {
+	&wakeup_script_erratum27,
+	&sleep_on_script_erratum27,
+	&wrst_script,
+};
+
+/**
+ * DOC: TWL4030 resource configuration
+ *
+ * VDD1/VDD2/VPLL are assigned to P1 and P3, to have better control
+ * during OFFMODE. HFCLKOUT is assigned to P1 and P3 (*p2) to turn off
+ * only during OFFMODE.
+ * (*P2 is included if the platform uses it for modem/some other processor)
+ */
+static struct twl4030_resconfig twl4030_rconfig_erratum27[] __initdata = {
+	{ .resource = RES_VPLL1, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = 3, .type2 = 1, .remap_sleep = RES_STATE_OFF },
+	{ .resource = RES_VINTANA1, .devgroup = DEV_GRP_ALL, .type = 1,
+		.type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_VINTANA2, .devgroup = DEV_GRP_ALL, .type = 0,
+		.type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_VINTDIG, .devgroup = DEV_GRP_ALL, .type = 1,
+		.type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_VIO, .devgroup = DEV_GRP_ALL, .type = 2,
+		.type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_VDD1, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = 4, .type2 = 1, .remap_sleep = RES_STATE_OFF },
+	{ .resource = RES_VDD2, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = 3, .type2 = 1, .remap_sleep = RES_STATE_OFF },
+	{ .resource = RES_REGEN, .devgroup = DEV_GRP_ALL, .type = 2,
+		.type2 = 1, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_NRES_PWRON, .devgroup = DEV_GRP_ALL, .type = 0,
+		.type2 = 1, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_CLKEN, .devgroup = DEV_GRP_ALL, .type = 3,
+		.type2 = 2, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_SYSEN, .devgroup = DEV_GRP_ALL, .type = 6,
+		.type2 = 1, .remap_sleep = RES_STATE_SLEEP },
+	{ .resource = RES_HFCLKOUT, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = 0, .type2 = 1, .remap_sleep = RES_STATE_SLEEP },
+	{ 0, 0},
+};
+
+/**
+ * twl5030_script_erratum27() - API to modify TWL4030 script
+ *
+ * Updating the TWL4030 script & resource configuration
+ */
+static void __init twl5030_script_erratum27(void)
+{
+	twl4030_generic_script.scripts = twl4030_scripts_erratum27;
+	twl4030_generic_script.num = ARRAY_SIZE(twl4030_scripts_erratum27);
+	twl4030_generic_script.resource_config = twl4030_rconfig_erratum27;
+}
+
+struct twl4030_power_data twl4030_generic_script __initdata = {
+	.scripts	= twl4030_scripts,
+	.num		= ARRAY_SIZE(twl4030_scripts),
+	.resource_config = twl4030_rconfig,
+	.twl5030_erratum27wa_script = twl5030_script_erratum27,
+};
+
+static int __init twl4030_script_probe(struct platform_device *pdev)
+{
+	return twl4030_power_init(&twl4030_generic_script);
+}
+
+static int twl4030_script_remove(struct platform_device *pdev)
+{
+	return twl4030_remove_script(TWL4030_SLEEP_SCRIPT |
+			TWL4030_WAKEUP12_SCRIPT | TWL4030_WAKEUP3_SCRIPT |
+			TWL4030_WRST_SCRIPT);
+}
+
+static struct platform_driver twl4030_script_driver = {
+	.remove	= twl4030_script_remove,
+	.driver	= {
+			.name = "twl4030_script",
+			.owner = THIS_MODULE,
+		},
+};
+
+static int __init twl4030_script_init(void)
+{
+	/* Register the TWL4030 script driver */
+	return platform_driver_probe(&twl4030_script_driver,
+					twl4030_script_probe);
+}
+
+static void __exit twl4030_script_cleanup(void)
+{
+	/* Unregister TWL4030 script driver */
+	platform_driver_unregister(&twl4030_script_driver);
+}
+
+/*
+module_init(twl4030_script_init);
+module_exit(twl4030_script_cleanup);
+*/
+
+MODULE_DESCRIPTION("OMAP TWL4030 script driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Texas Instruments Inc");
diff --git a/drivers/serial/max3100.c b/drivers/serial/max3100.c
index beb1afa..1e83f27 100644
--- a/drivers/serial/max3100.c
+++ b/drivers/serial/max3100.c
@@ -117,6 +117,8 @@ struct max3100_port {
 	int minor;		/* minor number */
 	int crystal;		/* 1 if 3.6864Mhz crystal 0 for 1.8432 */
 	int loopback;		/* 1 if we are in loopback mode */
+	int invert_rts;		/* 1 if RTS output logic is inverted */
+	int rts_sleep;		/* wait time for rts release */
 
 	/* for handling irqs: need workqueue since we do spi_sync */
 	struct workqueue_struct *workqueue;
@@ -279,6 +281,7 @@ static void max3100_work(struct work_struct *w)
 		if (cconf)
 			max3100_sr(s, MAX3100_WC | conf, &rx);
 		if (crts) {
+			// FIXME this only works for inverted RTS?
 			max3100_sr(s, MAX3100_WD | MAX3100_TE |
 				   (s->rts ? MAX3100_RTS : 0), &rx);
 			rxchars += max3100_handlerx(s, rx);
@@ -302,9 +305,22 @@ static void max3100_work(struct work_struct *w)
 			}
 			if (tx != 0xffff) {
 				max3100_calc_parity(s, &tx);
-				tx |= MAX3100_WD | (s->rts ? MAX3100_RTS : 0);
-				max3100_sr(s, tx, &rx);
-				rxchars += max3100_handlerx(s, rx);
+				if (s->invert_rts) {
+					// HACK force rts
+					tx |= MAX3100_WD | 0;
+					max3100_sr(s, tx, &rx);
+					rxchars += max3100_handlerx(s, rx);
+					udelay(s->rts_sleep);
+					// disable rts after send
+					max3100_sr(s, MAX3100_WD | MAX3100_TE |
+					   MAX3100_RTS, &rx);
+					//rxchars += max3100_handlerx(s, rx);
+				} else {
+					tx |= MAX3100_WD |
+						(s->rts ? MAX3100_RTS : 0);
+					max3100_sr(s, tx, &rx);
+					rxchars += max3100_handlerx(s, rx);
+				}
 			}
 		}
 
@@ -407,7 +423,7 @@ static void max3100_set_mctrl(struct uart_port *port, unsigned int mctrl)
 					      port);
 	int rts;
 
-	dev_dbg(&s->spi->dev, "%s\n", __func__);
+	dev_err(&s->spi->dev, "%s\n", __func__);
 
 	rts = (mctrl & TIOCM_RTS) > 0;
 
@@ -482,6 +498,7 @@ max3100_set_termios(struct uart_port *port, struct ktermios *termios,
 	default:
 		baud = s->baud;
 	}
+	s->rts_sleep = 1000000*10/baud;
 	tty_termios_encode_baud_rate(termios, baud, baud);
 	s->baud = baud;
 	param_mask |= MAX3100_BAUD;
@@ -589,7 +606,7 @@ static int max3100_startup(struct uart_port *port)
 
 	dev_dbg(&s->spi->dev, "%s\n", __func__);
 
-	s->conf = MAX3100_RM;
+	s->conf = MAX3100_RM | MAX3100_TM;
 	s->baud = s->crystal ? 230400 : 115200;
 	s->rx_enabled = 1;
 
@@ -780,6 +797,7 @@ static int __devinit max3100_probe(struct spi_device *spi)
 	pdata = spi->dev.platform_data;
 	max3100s[i]->crystal = pdata->crystal;
 	max3100s[i]->loopback = pdata->loopback;
+	max3100s[i]->invert_rts = pdata->invert_rts;
 	max3100s[i]->poll_time = pdata->poll_time * HZ / 1000;
 	if (pdata->poll_time > 0 && max3100s[i]->poll_time == 0)
 		max3100s[i]->poll_time = 1;
diff --git a/drivers/serial/omap-serial.c b/drivers/serial/omap-serial.c
index 849ab33..4e65678 100644
--- a/drivers/serial/omap-serial.c
+++ b/drivers/serial/omap-serial.c
@@ -517,6 +517,9 @@ static int serial_omap_startup(struct uart_port *port)
 	up->ier = UART_IER_RLSI | UART_IER_RDI;
 	serial_out(up, UART_IER, up->ier);
 
+	/* Enable module level wake up */
+	serial_out(up, UART_OMAP_WER, OMAP_UART_WER_MOD_WKUP);
+
 	up->port_activity = jiffies;
 	return 0;
 }
@@ -824,9 +827,6 @@ serial_omap_pm(struct uart_port *port, unsigned int state,
 	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 	serial_out(up, UART_EFR, efr);
 	serial_out(up, UART_LCR, 0);
-	/* Enable module level wake up */
-	serial_out(up, UART_OMAP_WER,
-		(state != 0) ? OMAP_UART_WER_MOD_WKUP : 0);
 }
 
 static void serial_omap_release_port(struct uart_port *port)
diff --git a/drivers/spi/omap2_mcspi.c b/drivers/spi/omap2_mcspi.c
index aaded7a..538a568 100644
--- a/drivers/spi/omap2_mcspi.c
+++ b/drivers/spi/omap2_mcspi.c
@@ -35,6 +35,7 @@
 #include <linux/slab.h>
 
 #include <linux/spi/spi.h>
+#include <linux/gpio.h>
 
 #include <plat/dma.h>
 #include <plat/clock.h>
@@ -133,6 +134,7 @@ struct omap2_mcspi {
 	unsigned long		phys;
 	/* SPI1 has 4 channels, while SPI2 has 2 */
 	struct omap2_mcspi_dma	*dma_channels;
+	int			*cs_gpios;
 };
 
 struct omap2_mcspi_cs {
@@ -232,6 +234,7 @@ static void omap2_mcspi_set_enable(const struct spi_device *spi, int enable)
 	u32 l;
 
 	l = enable ? OMAP2_MCSPI_CHCTRL_EN : 0;
+	// TODO does this break for GPIO CS?
 	mcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCTRL0, l);
 	/* Flash post-writes */
 	mcspi_read_cs_reg(spi, OMAP2_MCSPI_CHCTRL0);
@@ -241,6 +244,14 @@ static void omap2_mcspi_force_cs(struct spi_device *spi, int cs_active)
 {
 	u32 l;
 
+	struct omap2_mcspi* mcspi = spi_master_get_devdata(spi->master);
+	/* allow GPIOs as chip select if defined */
+	if (mcspi->cs_gpios && mcspi->cs_gpios[spi->chip_select]) {
+		int gpio = mcspi->cs_gpios[spi->chip_select];
+		gpio_set_value(gpio, !cs_active); /* low active */
+	}
+
+	// TXS times out unless we force the CHCONF reg as well
 	l = mcspi_cached_chconf0(spi);
 	MOD_REG_BIT(l, OMAP2_MCSPI_CHCONF_FORCE, cs_active);
 	mcspi_write_chconf0(spi, l);
@@ -541,7 +552,7 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)
 				dev_vdbg(&spi->dev, "read-%d %02x\n",
 						word_len, *(rx - 1));
 			}
-		} while (c > (word_len>>3));
+		} while (c);
 	} else if (word_len <= 16) {
 		u16		*rx;
 		const u16	*tx;
@@ -588,7 +599,7 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)
 				dev_vdbg(&spi->dev, "read-%d %04x\n",
 						word_len, *(rx - 1));
 			}
-		} while (c > (word_len>>3));
+		} while (c >= 2);
 	} else if (word_len <= 32) {
 		u32		*rx;
 		const u32	*tx;
@@ -635,7 +646,7 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)
 				dev_vdbg(&spi->dev, "read-%d %08x\n",
 						word_len, *(rx - 1));
 			}
-		} while (c > (word_len>>3));
+		} while (c >= 4);
 	}
 
 	/* for TX_ONLY mode, be sure all words have shifted out */
@@ -1158,6 +1169,7 @@ static int __init omap2_mcspi_probe(struct platform_device *pdev)
 	int			status = 0, i;
 	const u8		*rxdma_id, *txdma_id;
 	unsigned		num_chipselect;
+	struct omap2_mcspi_platform_config* pconfig = pdev->dev.platform_data;
 
 	switch (pdev->id) {
 	case 1:
@@ -1168,7 +1180,7 @@ static int __init omap2_mcspi_probe(struct platform_device *pdev)
 	case 2:
 		rxdma_id = spi2_rxdma_id;
 		txdma_id = spi2_txdma_id;
-		num_chipselect = 2;
+		num_chipselect = 4;
 		break;
 
 #if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) \
@@ -1211,6 +1223,10 @@ static int __init omap2_mcspi_probe(struct platform_device *pdev)
 
 	mcspi = spi_master_get_devdata(master);
 	mcspi->master = master;
+	if (pconfig && pconfig->cs_gpios)
+		mcspi->cs_gpios = pconfig->cs_gpios;
+	else
+		mcspi->cs_gpios = NULL;
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (r == NULL) {
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 233c288..5add8b5 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -315,7 +315,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	int			stopped;
 	unsigned		count = 0;
 	u8			state;
-	const __le32		halt = HALT_BIT(ehci);
 	struct ehci_qh_hw	*hw = qh->hw;
 
 	if (unlikely (list_empty (&qh->qtd_list)))
@@ -422,7 +421,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 					&& !(qtd->hw_alt_next
 						& EHCI_LIST_END(ehci))) {
 				stopped = 1;
-				goto halt;
 			}
 
 		/* stop scanning when we reach qtds the hc is using */
@@ -456,16 +454,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 				 */
 				ehci_clear_tt_buffer(ehci, qh, urb, token);
 			}
-
-			/* force halt for unlinked or blocked qh, so we'll
-			 * patch the qh later and so that completions can't
-			 * activate it while we "know" it's stopped.
-			 */
-			if ((halt & hw->hw_token) == 0) {
-halt:
-				hw->hw_token |= halt;
-				wmb ();
-			}
 		}
 
 		/* unless we already know the urb's status, collect qtd status
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 430094c..b4ac12f 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -984,7 +984,6 @@ void musb_start(struct musb *musb)
 
 	musb->is_active = 0;
 	devctl = musb_readb(regs, MUSB_DEVCTL);
-	devctl &= ~MUSB_DEVCTL_SESSION;
 
 	if (is_otg_enabled(musb)) {
 		/* session started after:
@@ -1608,6 +1607,10 @@ static irqreturn_t generic_interrupt(int irq, void *__hci)
 	if (musb->int_usb || musb->int_tx || musb->int_rx)
 		retval = musb_interrupt(musb);
 
+	/* Poll for ID change */
+	if (musb->ops->id_poll)
+		musb->ops->id_poll(musb);
+
 	spin_unlock_irqrestore(&musb->lock, flags);
 
 	return retval;
@@ -2486,13 +2489,19 @@ static int musb_suspend(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	unsigned long	flags;
 	struct musb	*musb = dev_to_musb(&pdev->dev);
+	u8 devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+	int ret = 0;
 
 	spin_lock_irqsave(&musb->lock, flags);
 
 	if (is_peripheral_active(musb)) {
-		/* FIXME force disconnect unless we know USB will wake
-		 * the system up quickly enough to respond ...
+		/*
+		 * Don't allow system suspend while peripheral mode
+		 * is actve and cable is connected to host.
 		 */
+		if ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS
+				&& (devctl & MUSB_DEVCTL_BDEVICE))
+			ret = -EBUSY;
 	} else if (is_host_active(musb)) {
 		/* we know all the children are suspended; sometimes
 		 * they will even be wakeup-enabled.
@@ -2500,7 +2509,7 @@ static int musb_suspend(struct device *dev)
 	}
 
 	spin_unlock_irqrestore(&musb->lock, flags);
-	return 0;
+	return ret;
 }
 
 static int musb_resume_noirq(struct device *dev)
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 8a70be1..73871dd 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -271,6 +271,8 @@ struct musb_platform_ops {
 
 	int	(*vbus_status)(struct musb *musb);
 	void	(*set_vbus)(struct musb *musb, int on);
+	void	(*id_poll)(struct musb *musb);
+
 	void (*read_fifo)(struct musb_hw_ep *hw_ep, u16 len, u8 *buf);
 	void (*write_fifo)(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf);
 	struct dma_controller* (*dma_controller_create)(struct musb *,
diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index 9de63aa..65ccaa7 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -321,8 +321,7 @@ static void txstate(struct musb *musb, struct musb_request *req)
 				((request->dma + request->actual) & 0x3) &&
 				(musb->hwvers >= MUSB_HWVERS_1800)) {
 
-				request_size = min_t(size_t,
-					max_ep_writesize(musb, musb_ep),
+				request_size = min_t(size_t, musb_ep->packet_sz,
 					request->length - request->actual);
 
 				musb_ep->dma->desired_mode = 0;
@@ -2075,7 +2074,7 @@ __acquires(musb->lock)
 	/* Normal reset, as B-Device;
 	 * or else after HNP, as A-Device
 	 */
-	if (devctl & MUSB_DEVCTL_BDEVICE) {
+	if (!(devctl & MUSB_DEVCTL_HM)) {
 		musb->xceiv->state = OTG_STATE_B_PERIPHERAL;
 		musb->g.is_a_peripheral = 0;
 	} else if (is_otg_enabled(musb)) {
diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 849a748..4211548 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -52,7 +52,13 @@ struct omap2430_glue {
 #define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
 static struct timer_list musb_idle_timer;
+#define  POLL_SECONDS    2
 
+static void omap2430_musb_id_change(struct musb *musb)
+{
+	if (is_otg_enabled(musb) && musb->xceiv->state == OTG_STATE_B_IDLE)
+		mod_timer(&musb_idle_timer, jiffies + POLL_SECONDS * HZ);
+}
 static void musb_do_idle(unsigned long _musb)
 {
 	struct musb	*musb = (void *)_musb;
@@ -71,12 +77,14 @@ static void musb_do_idle(unsigned long _musb)
 		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		if (devctl & MUSB_DEVCTL_BDEVICE) {
-			musb->xceiv->state = OTG_STATE_B_IDLE;
-			MUSB_DEV_MODE(musb);
-		} else {
+		if (devctl & MUSB_DEVCTL_HM) {
 			musb->xceiv->state = OTG_STATE_A_IDLE;
 			MUSB_HST_MODE(musb);
+		} else {
+			musb->xceiv->state = OTG_STATE_B_IDLE;
+			MUSB_DEV_MODE(musb);
+			mod_timer(&musb_idle_timer,
+					jiffies + POLL_SECONDS * HZ);
 		}
 		break;
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
@@ -100,11 +108,25 @@ static void musb_do_idle(unsigned long _musb)
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	case OTG_STATE_A_HOST:
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		if (devctl &  MUSB_DEVCTL_BDEVICE)
-			musb->xceiv->state = OTG_STATE_B_IDLE;
-		else
+		if (devctl &  MUSB_DEVCTL_HM)
 			musb->xceiv->state = OTG_STATE_A_WAIT_BCON;
+		else
+			musb->xceiv->state = OTG_STATE_B_IDLE;
 #endif
+	case OTG_STATE_B_IDLE:
+		if (!is_peripheral_enabled(musb))
+			break;
+
+		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+		if (devctl & MUSB_DEVCTL_HM) {
+			musb->xceiv->state = OTG_STATE_A_HOST;
+		} else {
+			mod_timer(&musb_idle_timer,
+					jiffies + POLL_SECONDS * HZ);
+			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl |
+				MUSB_DEVCTL_SESSION);
+		}
+		break;
 	default:
 		break;
 	}
@@ -406,6 +428,7 @@ static const struct musb_platform_ops omap2430_ops = {
 	.try_idle	= omap2430_musb_try_idle,
 
 	.set_vbus	= omap2430_musb_set_vbus,
+	.id_poll	= omap2430_musb_id_change,
 
 	.read_fifo	= musb_read_fifo,
 	.write_fifo	= musb_write_fifo,
diff --git a/include/linux/i2c/twl.h b/include/linux/i2c/twl.h
index 27d1eb6..52ae5c4 100644
--- a/include/linux/i2c/twl.h
+++ b/include/linux/i2c/twl.h
@@ -150,7 +150,12 @@
 #define MMC_PU				(0x1 << 3)
 #define MMC_PD				(0x1 << 2)
 
-
+#define TWL_SIL_TYPE(rev)		((rev) & 0x00FFFFFF)
+#define TWL_SIL_REV(rev)		((rev) >> 24)
+#define TWL_SIL_5030			0x09002F
+#define TWL5030_REV_1_0			0x00
+#define TWL5030_REV_1_1			0x10
+#define TWL5030_REV_1_2			0x30
 
 #define TWL4030_CLASS_ID 		0x4030
 #define TWL6030_CLASS_ID 		0x6030
@@ -180,6 +185,9 @@ int twl_i2c_read_u8(u8 mod_no, u8 *val, u8 reg);
 int twl_i2c_write(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes);
 int twl_i2c_read(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes);
 
+int twl_get_type(void);
+int twl_get_version(void);
+
 int twl6030_interrupt_unmask(u8 bit_mask, u8 offset);
 int twl6030_interrupt_mask(u8 bit_mask, u8 offset);
 
@@ -204,6 +212,12 @@ static inline int twl6030_mmc_card_detect(struct device *dev, int slot)
 	return -EIO;
 }
 #endif
+
+#ifdef CONFIG_TWL4030_POWER
+extern struct twl4030_power_data twl4030_generic_script;
+#else
+#define twl4030_generic_script	NULL;
+#endif
 /*----------------------------------------------------------------------*/
 
 /*
@@ -279,7 +293,12 @@ static inline int twl6030_mmc_card_detect(struct device *dev, int slot)
  *(Use TWL_4030_MODULE_INTBR)
  */
 
+#define REG_IDCODE_7_0			0x00
+#define REG_IDCODE_15_8			0x01
+#define REG_IDCODE_16_23		0x02
+#define REG_IDCODE_31_24		0x03
 #define REG_GPPUPDCTR1			0x0F
+#define REG_UNLOCK_TEST_REG		0x12
 
 /*I2C1 and I2C4(SR) SDA/SCL pull-up control bits */
 
@@ -288,6 +307,8 @@ static inline int twl6030_mmc_card_detect(struct device *dev, int slot)
 #define SR_I2C_SCL_CTRL_PU		BIT(4)
 #define SR_I2C_SDA_CTRL_PU		BIT(6)
 
+#define TWL_EEPROM_R_UNLOCK		0x49
+
 /*----------------------------------------------------------------------*/
 
 /*
@@ -436,9 +457,23 @@ static inline int twl6030_mmc_card_detect(struct device *dev, int slot)
 
 /* Power bus message definitions */
 
-/* The TWL4030/5030 splits its power-management resources (the various
- * regulators, clock and reset lines) into 3 processor groups - P1, P2 and
- * P3. These groups can then be configured to transition between sleep, wait-on
+/*
+ * The TWL4030/5030 splits its power-management resources (the various
+ * regulators, clock and reset lines) into 3 processor groups - P1, P2 and P3.
+ *
+ * Resources attached to device group P1 is managed depending on the state of
+ * NSLEEP1 pin of TWL4030, which is connected to sys_off signal from OMAP
+ *
+ * Resources attached to device group P2 is managed depending on the state of
+ * NSLEEP2 pin of TWL4030, which is can be connected to a modem or
+ * connectivity chip
+ *
+ * Resources attached to device group P3 is managed depending on the state of
+ * CLKREQ pin of TWL4030, which is connected to clk request signal from OMAP
+ *
+ * If required these resources can be attached to combination of P1/P2/P3.
+ *
+ * These groups can then be configured to transition between sleep, wait-on
  * and active states by sending messages to the power bus.  See Section 5.4.2
  * Power Resources of TWL4030 TRM
  */
@@ -448,7 +483,17 @@ static inline int twl6030_mmc_card_detect(struct device *dev, int slot)
 #define DEV_GRP_P1		0x1	/* P1: all OMAP devices */
 #define DEV_GRP_P2		0x2	/* P2: all Modem devices */
 #define DEV_GRP_P3		0x4	/* P3: all peripheral devices */
+#define DEV_GRP_ALL		0x7	/* P1/P2/P3: all devices */
 
+/*
+ * The 27 power resources in TWL4030 is again divided into
+ * analog resources:
+ *	Power Providers - LDO regulators, dc-to-dc regulators
+ *	Power Reference - analog reference
+ *
+ * and digital resources:
+ *	Reset & Clock - reset and clock signals.
+ */
 /* Resource groups */
 #define RES_GRP_RES		0x0	/* Reserved */
 #define RES_GRP_PP		0x1	/* Power providers */
@@ -460,7 +505,10 @@ static inline int twl6030_mmc_card_detect(struct device *dev, int slot)
 #define RES_GRP_ALL		0x7	/* All resource groups */
 
 #define RES_TYPE2_R0		0x0
+#define RES_TYPE2_R1		0x1
+#define RES_TYPE2_R2		0x2
 
+#define RES_TYPE_R0		0x0
 #define RES_TYPE_ALL		0x7
 
 /* Resource states */
@@ -501,7 +549,7 @@ static inline int twl6030_mmc_card_detect(struct device *dev, int slot)
 #define RES_32KCLKOUT           26
 #define RES_RESET               27
 /* Power Reference */
-#define RES_Main_Ref            28
+#define RES_MAIN_REF            28
 
 #define TOTAL_RESOURCES		28
 /*
@@ -623,12 +671,13 @@ struct twl4030_power_data {
 	struct twl4030_script **scripts;
 	unsigned num;
 	struct twl4030_resconfig *resource_config;
+	void (*twl5030_erratum27wa_script)(void);
 #define TWL4030_RESCONFIG_UNDEF	((u8)-1)
 };
 
-extern void twl4030_power_init(struct twl4030_power_data *triton2_scripts);
-extern void twl4030_power_sr_init(void);
+extern int twl4030_power_init(struct twl4030_power_data *triton2_scripts);
 extern int twl4030_remove_script(u8 flags);
+extern void twl4030_power_sr_init(void);
 
 struct twl4030_codec_audio_data {
 	unsigned int audio_mclk; /* not used, will be removed */
diff --git a/include/linux/serial_max3100.h b/include/linux/serial_max3100.h
index 4976bef..d14cf77 100644
--- a/include/linux/serial_max3100.h
+++ b/include/linux/serial_max3100.h
@@ -21,6 +21,9 @@
  *                       called on suspend and resume to activate it.
  * @poll_time:           poll time for CTS signal in ms, 0 disables (so no hw
  *                       flow ctrl is possible but you have less CPU usage)
+ * @invert_rts           datasheet schematic for MAX3140 is wrong, as it
+ *                       it enables the driver when RTS is OFF and the other
+ *                       way around. Set this to 1 to invert the RTS logic.
  *
  * You should use this structure in your machine description to specify
  * how the MAX3100 is connected. Example:
@@ -29,6 +32,7 @@
  *  .loopback = 0,
  *  .crystal = 0,
  *  .poll_time = 100,
+ *  .inverrts = 0,
  * };
  *
  * static struct spi_board_info spi_board_info[] = {
@@ -47,6 +51,7 @@ struct plat_max3100 {
 	int crystal;
 	void (*max3100_hw_suspend) (int suspend);
 	int poll_time;
+	int invert_rts;
 };
 
 #endif
diff --git a/scripts/kconfig/lxdialog/checklist.c b/scripts/kconfig/lxdialog/checklist.c
index a2eb80f..8407849 100644
--- a/scripts/kconfig/lxdialog/checklist.c
+++ b/scripts/kconfig/lxdialog/checklist.c
@@ -37,20 +37,20 @@ static void print_item(WINDOW * win, int choice, int selected)
 	list_item[list_width - item_x] = '\0';
 
 	/* Clear 'residue' of last item */
-	wattrset(win, dlg.menubox.atr);
+	(void)wattrset(win, dlg.menubox.atr);
 	wmove(win, choice, 0);
 	for (i = 0; i < list_width; i++)
 		waddch(win, ' ');
 
 	wmove(win, choice, check_x);
-	wattrset(win, selected ? dlg.check_selected.atr
+	(void)wattrset(win, selected ? dlg.check_selected.atr
 		 : dlg.check.atr);
 	if (!item_is_tag(':'))
 		wprintw(win, "(%c)", item_is_tag('X') ? 'X' : ' ');
 
-	wattrset(win, selected ? dlg.tag_selected.atr : dlg.tag.atr);
+	(void)wattrset(win, selected ? dlg.tag_selected.atr : dlg.tag.atr);
 	mvwaddch(win, choice, item_x, list_item[0]);
-	wattrset(win, selected ? dlg.item_selected.atr : dlg.item.atr);
+	(void)wattrset(win, selected ? dlg.item_selected.atr : dlg.item.atr);
 	waddstr(win, list_item + 1);
 	if (selected) {
 		wmove(win, choice, check_x + 1);
@@ -68,11 +68,11 @@ static void print_arrows(WINDOW * win, int choice, int item_no, int scroll,
 	wmove(win, y, x);
 
 	if (scroll > 0) {
-		wattrset(win, dlg.uarrow.atr);
+		(void)wattrset(win, dlg.uarrow.atr);
 		waddch(win, ACS_UARROW);
 		waddstr(win, "(-)");
 	} else {
-		wattrset(win, dlg.menubox.atr);
+		(void)wattrset(win, dlg.menubox.atr);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
@@ -83,11 +83,11 @@ static void print_arrows(WINDOW * win, int choice, int item_no, int scroll,
 	wmove(win, y, x);
 
 	if ((height < item_no) && (scroll + choice < item_no - 1)) {
-		wattrset(win, dlg.darrow.atr);
+		(void)wattrset(win, dlg.darrow.atr);
 		waddch(win, ACS_DARROW);
 		waddstr(win, "(+)");
 	} else {
-		wattrset(win, dlg.menubox_border.atr);
+		(void)wattrset(win, dlg.menubox_border.atr);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
@@ -150,16 +150,16 @@ do_resize:
 
 	draw_box(dialog, 0, 0, height, width,
 		 dlg.dialog.atr, dlg.border.atr);
-	wattrset(dialog, dlg.border.atr);
+	(void)wattrset(dialog, dlg.border.atr);
 	mvwaddch(dialog, height - 3, 0, ACS_LTEE);
 	for (i = 0; i < width - 2; i++)
 		waddch(dialog, ACS_HLINE);
-	wattrset(dialog, dlg.dialog.atr);
+	(void)wattrset(dialog, dlg.dialog.atr);
 	waddch(dialog, ACS_RTEE);
 
 	print_title(dialog, title, width);
 
-	wattrset(dialog, dlg.dialog.atr);
+	(void)wattrset(dialog, dlg.dialog.atr);
 	print_autowrap(dialog, prompt, width - 2, 1, 3);
 
 	list_width = width - 6;
diff --git a/scripts/kconfig/lxdialog/inputbox.c b/scripts/kconfig/lxdialog/inputbox.c
index dd8e587..a5402c5 100644
--- a/scripts/kconfig/lxdialog/inputbox.c
+++ b/scripts/kconfig/lxdialog/inputbox.c
@@ -71,16 +71,16 @@ do_resize:
 
 	draw_box(dialog, 0, 0, height, width,
 		 dlg.dialog.atr, dlg.border.atr);
-	wattrset(dialog, dlg.border.atr);
+	(void)wattrset(dialog, dlg.border.atr);
 	mvwaddch(dialog, height - 3, 0, ACS_LTEE);
 	for (i = 0; i < width - 2; i++)
 		waddch(dialog, ACS_HLINE);
-	wattrset(dialog, dlg.dialog.atr);
+	(void)wattrset(dialog, dlg.dialog.atr);
 	waddch(dialog, ACS_RTEE);
 
 	print_title(dialog, title, width);
 
-	wattrset(dialog, dlg.dialog.atr);
+	(void)wattrset(dialog, dlg.dialog.atr);
 	print_autowrap(dialog, prompt, width - 2, 1, 3);
 
 	/* Draw the input field box */
@@ -95,7 +95,7 @@ do_resize:
 
 	/* Set up the initial value */
 	wmove(dialog, box_y, box_x);
-	wattrset(dialog, dlg.inputbox.atr);
+	(void)wattrset(dialog, dlg.inputbox.atr);
 
 	input_x = strlen(instr);
 
@@ -128,7 +128,7 @@ do_resize:
 			case KEY_BACKSPACE:
 			case 127:
 				if (input_x || scroll) {
-					wattrset(dialog, dlg.inputbox.atr);
+					(void)wattrset(dialog, dlg.inputbox.atr);
 					if (!input_x) {
 						scroll = scroll < box_width - 1 ? 0 : scroll - (box_width - 1);
 						wmove(dialog, box_y, box_x);
@@ -148,7 +148,7 @@ do_resize:
 			default:
 				if (key < 0x100 && isprint(key)) {
 					if (scroll + input_x < MAX_LEN) {
-						wattrset(dialog, dlg.inputbox.atr);
+						(void)wattrset(dialog, dlg.inputbox.atr);
 						instr[scroll + input_x] = key;
 						instr[scroll + input_x + 1] = '\0';
 						if (input_x == box_width - 1) {
diff --git a/scripts/kconfig/lxdialog/menubox.c b/scripts/kconfig/lxdialog/menubox.c
index 1d60473..aa1e21b 100644
--- a/scripts/kconfig/lxdialog/menubox.c
+++ b/scripts/kconfig/lxdialog/menubox.c
@@ -74,7 +74,7 @@ static void do_print_item(WINDOW * win, const char *item, int line_y,
 	j = first_alpha(menu_item, "YyNnMmHh");
 
 	/* Clear 'residue' of last item */
-	wattrset(win, dlg.menubox.atr);
+	(void)wattrset(win, dlg.menubox.atr);
 	wmove(win, line_y, 0);
 #if OLD_NCURSES
 	{
@@ -85,10 +85,10 @@ static void do_print_item(WINDOW * win, const char *item, int line_y,
 #else
 	wclrtoeol(win);
 #endif
-	wattrset(win, selected ? dlg.item_selected.atr : dlg.item.atr);
+	(void)wattrset(win, selected ? dlg.item_selected.atr : dlg.item.atr);
 	mvwaddstr(win, line_y, item_x, menu_item);
 	if (hotkey) {
-		wattrset(win, selected ? dlg.tag_key_selected.atr
+		(void)wattrset(win, selected ? dlg.tag_key_selected.atr
 			 : dlg.tag_key.atr);
 		mvwaddch(win, line_y, item_x + j, menu_item[j]);
 	}
@@ -118,11 +118,11 @@ static void print_arrows(WINDOW * win, int item_no, int scroll, int y, int x,
 	wmove(win, y, x);
 
 	if (scroll > 0) {
-		wattrset(win, dlg.uarrow.atr);
+		(void)wattrset(win, dlg.uarrow.atr);
 		waddch(win, ACS_UARROW);
 		waddstr(win, "(-)");
 	} else {
-		wattrset(win, dlg.menubox.atr);
+		(void)wattrset(win, dlg.menubox.atr);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
@@ -134,11 +134,11 @@ static void print_arrows(WINDOW * win, int item_no, int scroll, int y, int x,
 	wrefresh(win);
 
 	if ((height < item_no) && (scroll + height < item_no)) {
-		wattrset(win, dlg.darrow.atr);
+		(void)wattrset(win, dlg.darrow.atr);
 		waddch(win, ACS_DARROW);
 		waddstr(win, "(+)");
 	} else {
-		wattrset(win, dlg.menubox_border.atr);
+		(void)wattrset(win, dlg.menubox_border.atr);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
 		waddch(win, ACS_HLINE);
@@ -211,17 +211,17 @@ do_resize:
 
 	draw_box(dialog, 0, 0, height, width,
 		 dlg.dialog.atr, dlg.border.atr);
-	wattrset(dialog, dlg.border.atr);
+	(void)wattrset(dialog, dlg.border.atr);
 	mvwaddch(dialog, height - 3, 0, ACS_LTEE);
 	for (i = 0; i < width - 2; i++)
 		waddch(dialog, ACS_HLINE);
-	wattrset(dialog, dlg.dialog.atr);
+	(void)wattrset(dialog, dlg.dialog.atr);
 	wbkgdset(dialog, dlg.dialog.atr & A_COLOR);
 	waddch(dialog, ACS_RTEE);
 
 	print_title(dialog, title, width);
 
-	wattrset(dialog, dlg.dialog.atr);
+	(void)wattrset(dialog, dlg.dialog.atr);
 	print_autowrap(dialog, prompt, width - 2, 1, 3);
 
 	menu_width = width - 6;
diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index c704712..7452c85 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -95,7 +95,7 @@ do_resize:
 	boxh = height - 4;
 	boxw = width - 2;
 	box = subwin(dialog, boxh, boxw, y + 1, x + 1);
-	wattrset(box, dlg.dialog.atr);
+	(void)wattrset(box, dlg.dialog.atr);
 	wbkgdset(box, dlg.dialog.atr & A_COLOR);
 
 	keypad(box, TRUE);
@@ -104,11 +104,11 @@ do_resize:
 	draw_box(dialog, 0, 0, height, width,
 		 dlg.dialog.atr, dlg.border.atr);
 
-	wattrset(dialog, dlg.border.atr);
+	(void)wattrset(dialog, dlg.border.atr);
 	mvwaddch(dialog, height - 3, 0, ACS_LTEE);
 	for (i = 0; i < width - 2; i++)
 		waddch(dialog, ACS_HLINE);
-	wattrset(dialog, dlg.dialog.atr);
+	(void)wattrset(dialog, dlg.dialog.atr);
 	wbkgdset(dialog, dlg.dialog.atr & A_COLOR);
 	waddch(dialog, ACS_RTEE);
 
@@ -383,7 +383,7 @@ static void print_position(WINDOW * win)
 {
 	int percent;
 
-	wattrset(win, dlg.position_indicator.atr);
+	(void)wattrset(win, dlg.position_indicator.atr);
 	wbkgdset(win, dlg.position_indicator.atr & A_COLOR);
 	percent = (page - buf) * 100 / strlen(buf);
 	wmove(win, getmaxy(win) - 3, getmaxx(win) - 9);
diff --git a/scripts/kconfig/lxdialog/util.c b/scripts/kconfig/lxdialog/util.c
index f2375ad..97a60ab 100644
--- a/scripts/kconfig/lxdialog/util.c
+++ b/scripts/kconfig/lxdialog/util.c
@@ -240,7 +240,7 @@ void attr_clear(WINDOW * win, int height, int width, chtype attr)
 {
 	int i, j;
 
-	wattrset(win, attr);
+	(void)wattrset(win, attr);
 	for (i = 0; i < height; i++) {
 		wmove(win, i, 0);
 		for (j = 0; j < width; j++)
@@ -256,7 +256,7 @@ void dialog_clear(void)
 	if (dlg.backtitle != NULL) {
 		int i;
 
-		wattrset(stdscr, dlg.screen.atr);
+		(void)wattrset(stdscr, dlg.screen.atr);
 		mvwaddstr(stdscr, 0, 1, (char *)dlg.backtitle);
 		wmove(stdscr, 1, 1);
 		for (i = 1; i < COLS - 1; i++)
@@ -313,7 +313,7 @@ void print_title(WINDOW *dialog, const char *title, int width)
 {
 	if (title) {
 		int tlen = MIN(width - 2, strlen(title));
-		wattrset(dialog, dlg.title.atr);
+		(void)wattrset(dialog, dlg.title.atr);
 		mvwaddch(dialog, 0, (width - tlen) / 2 - 1, ' ');
 		mvwaddnstr(dialog, 0, (width - tlen)/2, title, tlen);
 		waddch(dialog, ' ');
@@ -393,22 +393,22 @@ void print_button(WINDOW * win, const char *label, int y, int x, int selected)
 	int i, temp;
 
 	wmove(win, y, x);
-	wattrset(win, selected ? dlg.button_active.atr
+	(void)wattrset(win, selected ? dlg.button_active.atr
 		 : dlg.button_inactive.atr);
 	waddstr(win, "<");
 	temp = strspn(label, " ");
 	label += temp;
-	wattrset(win, selected ? dlg.button_label_active.atr
+	(void)wattrset(win, selected ? dlg.button_label_active.atr
 		 : dlg.button_label_inactive.atr);
 	for (i = 0; i < temp; i++)
 		waddch(win, ' ');
-	wattrset(win, selected ? dlg.button_key_active.atr
+	(void)wattrset(win, selected ? dlg.button_key_active.atr
 		 : dlg.button_key_inactive.atr);
 	waddch(win, label[0]);
-	wattrset(win, selected ? dlg.button_label_active.atr
+	(void)wattrset(win, selected ? dlg.button_label_active.atr
 		 : dlg.button_label_inactive.atr);
 	waddstr(win, (char *)label + 1);
-	wattrset(win, selected ? dlg.button_active.atr
+	(void)wattrset(win, selected ? dlg.button_active.atr
 		 : dlg.button_inactive.atr);
 	waddstr(win, ">");
 	wmove(win, y, x + temp + 1);
@@ -423,7 +423,7 @@ draw_box(WINDOW * win, int y, int x, int height, int width,
 {
 	int i, j;
 
-	wattrset(win, 0);
+	(void)wattrset(win, 0);
 	for (i = 0; i < height; i++) {
 		wmove(win, y + i, x);
 		for (j = 0; j < width; j++)
@@ -457,7 +457,7 @@ void draw_shadow(WINDOW * win, int y, int x, int height, int width)
 	int i;
 
 	if (has_colors()) {	/* Whether terminal supports color? */
-		wattrset(win, dlg.shadow.atr);
+		(void)wattrset(win, dlg.shadow.atr);
 		wmove(win, y + height, x + 2);
 		for (i = 0; i < width; i++)
 			waddch(win, winch(win) & A_CHARTEXT);
diff --git a/scripts/kconfig/lxdialog/yesno.c b/scripts/kconfig/lxdialog/yesno.c
index 4e6e809..b1db7d9 100644
--- a/scripts/kconfig/lxdialog/yesno.c
+++ b/scripts/kconfig/lxdialog/yesno.c
@@ -61,16 +61,16 @@ do_resize:
 
 	draw_box(dialog, 0, 0, height, width,
 		 dlg.dialog.atr, dlg.border.atr);
-	wattrset(dialog, dlg.border.atr);
+	(void)wattrset(dialog, dlg.border.atr);
 	mvwaddch(dialog, height - 3, 0, ACS_LTEE);
 	for (i = 0; i < width - 2; i++)
 		waddch(dialog, ACS_HLINE);
-	wattrset(dialog, dlg.dialog.atr);
+	(void)wattrset(dialog, dlg.dialog.atr);
 	waddch(dialog, ACS_RTEE);
 
 	print_title(dialog, title, width);
 
-	wattrset(dialog, dlg.dialog.atr);
+	(void)wattrset(dialog, dlg.dialog.atr);
 	print_autowrap(dialog, prompt, width - 2, 1, 3);
 
 	print_buttons(dialog, height, width, 0);
