diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index dfa5464..aa15081 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -222,6 +222,11 @@ config MACH_OMAP_3430SDP
 	default y
 	select OMAP_PACKAGE_CBB
 
+config MACH_PIA_AM35X
+	bool "piA AM35x board (AM3505)"
+	depends on ARCH_OMAP3
+	select OMAP_PACKAGE_CBB
+
 config MACH_NOKIA_N800
        bool
 
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index 4cf039f..e2bea63 100755
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -244,7 +244,8 @@ obj-$(CONFIG_MACH_OMAP3517EVM)		+= board-am3517evm.o \
 					   board-flash.o \
 					   hsmmc.o
 
-obj-$(CONFIG_MACH_CRANEBOARD)		+= board-am3517crane.o
+obj-$(CONFIG_MACH_CRANEBOARD)		+= board-am3517crane.o \
+					   hsmmc.o
 
 obj-$(CONFIG_MACH_SBC3530)		+= board-omap3stalker.o \
 					   hsmmc.o
@@ -254,6 +255,8 @@ obj-$(CONFIG_MACH_TI8148EVM)		+= board-ti8148evm.o \
 obj-$(CONFIG_MACH_TI8168EVM)		+= board-ti8168evm.o \
 					   hsmmc.o \
 					   board-flash.o
+obj-$(CONFIG_MACH_PIA_AM35X)		+= board-am35xpia.o \
+					   hsmmc.o
 # Platform specific device init code
 usbfs-$(CONFIG_ARCH_OMAP_OTG)		:= usb-fs.o
 obj-y					+= $(usbfs-m) $(usbfs-y)
diff --git a/arch/arm/mach-omap2/board-am3517crane.c b/arch/arm/mach-omap2/board-am3517crane.c
index 71acb5a..0237940 100644
--- a/arch/arm/mach-omap2/board-am3517crane.c
+++ b/arch/arm/mach-omap2/board-am3517crane.c
@@ -19,23 +19,36 @@
 
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/davinci_emac.h>
 #include <linux/gpio.h>
+#include <linux/mfd/tps6507x.h>
+#include <linux/mmc/host.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/tps6507x.h>
+#include <linux/regulator/fixed.h>
+#include <linux/wl12xx.h>
+#include <linux/can/platform/ti_hecc.h>
 
 #include <mach/hardware.h>
+#include <mach/am35xx.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 
 #include <plat/board.h>
 #include <plat/common.h>
+#include <plat/gpmc.h>
+#include <plat/nand.h>
 #include <plat/usb.h>
 
 #include "mux.h"
 #include "control.h"
-
-#define GPIO_USB_POWER		35
-#define GPIO_USB_NRESET		38
-
+#include "hsmmc.h"
+#include "board-flash.h"
 
 /* Board initialization */
 static struct omap_board_config_kernel am3517_crane_config[] __initdata = {
@@ -43,40 +56,855 @@ static struct omap_board_config_kernel am3517_crane_config[] __initdata = {
 
 #ifdef CONFIG_OMAP_MUX
 static struct omap_board_mux board_mux[] __initdata = {
-	{ .reg_offset = OMAP_MUX_TERMINATOR },
+		/* only fixed MUXes here, don't add anything on expansions */
+
+		/* MMC1_CD        GPIO 041, low == card in slot */
+		OMAP3_MUX(GPMC_A8, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLUP),
+
+		/* EN_GSM_POWER   GPIO 029, low active */
+		OMAP3_MUX(ETK_D15,     OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+		/* GSM_nRESET     GPIO 126, low active */
+		OMAP3_MUX(SDMMC1_DAT4, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+		/* nGSM_ON/OFF    GPIO 127, low active */
+		OMAP3_MUX(SDMMC1_DAT5, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+
+		/* UART2.485/#232 GPIO 128, low = RS232 */
+		OMAP3_MUX(SDMMC1_DAT6, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+		/* UART2.SLEW     GPIO 129 */
+		OMAP3_MUX(SDMMC1_DAT7, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+
+		/* undocumented */
+		//OMAP3_MUX(CHASSIS_DMAREQ3, OMAP_MUX_MODE0 | OMAP_PIN_INPUT_PULLDOWN),
+		/* MCBSP_CLKS     GPIO 160 */
+		//OMAP3_MUX(MCBSP_CLKS, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLUP),
+
+		/* INPUT_GPIO1    GPIO 055 */
+		OMAP3_MUX(GPMC_NCS4, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLUP),
+		/* INPUT_GPIO2    GPIO 056 */
+		OMAP3_MUX(GPMC_NCS5, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLUP),
+
+		/* ETHERNET_nRST  GPIO 065 */
+		OMAP3_MUX(GPMC_WAIT3, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+
+		/* WLAN.EN        GPIO 139 */
+		OMAP3_MUX(SDMMC2_DAT7, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLDOWN/* OMAP_PIN_OUTPUT*/),
+		/* BT.EN          GPIO 138 */
+		OMAP3_MUX(SDMMC2_DAT6, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLDOWN/*OMAP_PIN_OUTPUT*/),
+		/* WLAN.IRQ       GPIO 137 */
+		OMAP3_MUX(SDMMC2_DAT5, OMAP_MUX_MODE4 | OMAP_PIN_INPUT),
+		/*        GPIO 136 */
+		OMAP3_MUX(SDMMC2_DAT5, OMAP_MUX_MODE4 | OMAP_PIN_INPUT/*OMAP_PIN_OUTPUT*/),
+		/* TERMINATOR */
+		{ .reg_offset = OMAP_MUX_TERMINATOR },
 };
 #else
 #define board_mux	NULL
 #endif
 
-static void __init am3517_crane_init_irq(void)
-{
-	omap_board_config = am3517_crane_config;
-	omap_board_config_size = ARRAY_SIZE(am3517_crane_config);
-
-	omap2_init_common_infrastructure();
-	omap2_init_common_devices(NULL, NULL);
-	omap_init_irq();
-}
-
+#if 0 /* USB EHCI port only on expansion port */
 static struct ehci_hcd_omap_platform_data ehci_pdata __initdata = {
 	.port_mode[0] = EHCI_HCD_OMAP_MODE_PHY,
 	.port_mode[1] = EHCI_HCD_OMAP_MODE_UNKNOWN,
 	.port_mode[2] = EHCI_HCD_OMAP_MODE_UNKNOWN,
 
 	.phy_reset  = true,
-	.reset_gpio_port[0]  = GPIO_USB_NRESET,
+	.reset_gpio_port[0]  = -EINVAL,
 	.reset_gpio_port[1]  = -EINVAL,
 	.reset_gpio_port[2]  = -EINVAL
 };
+#endif
+
+/*
+ * Ethernet (internal) & PHY (SMSC LAN8720A-CP)
+ */
+#define GPIO_ETHERNET_NRST 65
+#define AM35XX_EVM_MDIO_FREQUENCY	(1000000)
+
+static struct mdio_platform_data pia35x_evm_mdio_pdata = {
+	.bus_freq	= AM35XX_EVM_MDIO_FREQUENCY,
+};
+
+static struct resource pia35x_mdio_resources[] = {
+	{
+		.start  = AM35XX_IPSS_EMAC_BASE + AM35XX_EMAC_MDIO_OFFSET,
+		.end    = AM35XX_IPSS_EMAC_BASE + AM35XX_EMAC_MDIO_OFFSET +
+			  SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device pia35x_mdio_device = {
+	.name		= "davinci_mdio",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(pia35x_mdio_resources),
+	.resource	= pia35x_mdio_resources,
+	.dev.platform_data = &pia35x_evm_mdio_pdata,
+};
+
+static struct emac_platform_data pia35x_emac_pdata = {
+	.rmii_en	= 1,
+};
+
+static struct resource pia35x_emac_resources[] = {
+	{
+		.start  = AM35XX_IPSS_EMAC_BASE,
+		.end    = AM35XX_IPSS_EMAC_BASE + 0x2FFFF,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_RXTHRESH_IRQ,
+		.end    = INT_35XX_EMAC_C0_RXTHRESH_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_RX_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_RX_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_TX_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_TX_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_MISC_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_MISC_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device pia35x_emac_device = {
+	.name           = "davinci_emac",
+	.id	            = -1,
+	.num_resources  = ARRAY_SIZE(pia35x_emac_resources),
+	.resource       = pia35x_emac_resources,
+};
+
+/*
+ * initialize MAC address from boot parameter eth=<MAC>
+ */
+static int __init eth_addr_setup(char *str)
+{
+	int i;
+
+	if (str == NULL)
+		return 0;
+	for (i = 0; i < ETH_ALEN; i++)
+		pia35x_emac_pdata.mac_addr[i] = simple_strtol(&str[i*3],
+				(char **)NULL, 16);
+	return 1;
+}
+/* Get MAC address from kernel boot parameter eth=AA:BB:CC:DD:EE:FF */
+__setup("eth=", eth_addr_setup);
+
+/*
+ * disable ETH interrupt
+ */
+static void pia35x_enable_ethernet_int(void)
+{
+	u32 regval;
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = (regval | AM35XX_CPGMAC_C0_RX_PULSE_CLR |
+			AM35XX_CPGMAC_C0_TX_PULSE_CLR |
+			AM35XX_CPGMAC_C0_MISC_PULSE_CLR |
+			AM35XX_CPGMAC_C0_RX_THRESH_CLR);
+	omap_ctrl_writel(regval, AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+}
+
+/*
+ * enable ETH interrupt
+ */
+static void pia35x_disable_ethernet_int(void)
+{
+	u32 regval;
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = (regval | AM35XX_CPGMAC_C0_RX_PULSE_CLR |
+		AM35XX_CPGMAC_C0_TX_PULSE_CLR);
+	omap_ctrl_writel(regval, AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+}
+
+/*
+ * ETH init
+ * make sure ETH module is powered
+ * initialize MAC, PHY and configurationn
+ */
+static void __init pia35x_ethernet_init(struct emac_platform_data *pdata)
+{
+	u32 regval, mac_lo, mac_hi;
+
+	/* unset reset */
+	gpio_request(GPIO_ETHERNET_NRST, "ethernet-nrst");
+	gpio_direction_output(GPIO_ETHERNET_NRST, 1);
+	msleep(50);
+
+	mac_lo = omap_ctrl_readl(AM35XX_CONTROL_FUSE_EMAC_LSB);
+	mac_hi = omap_ctrl_readl(AM35XX_CONTROL_FUSE_EMAC_MSB);
+
+	pdata->mac_addr[0] = (u_int8_t)((mac_hi & 0xFF0000) >> 16);
+	pdata->mac_addr[1] = (u_int8_t)((mac_hi & 0xFF00)   >> 8);
+	pdata->mac_addr[2] = (u_int8_t)((mac_hi & 0xFF)     >> 0);
+	pdata->mac_addr[3] = (u_int8_t)((mac_lo & 0xFF0000) >> 16);
+	pdata->mac_addr[4] = (u_int8_t)((mac_lo & 0xFF00)   >> 8);
+	pdata->mac_addr[5] = (u_int8_t)((mac_lo & 0xFF)     >> 0);
+
+	pdata->ctrl_reg_offset      = AM35XX_EMAC_CNTRL_OFFSET;
+	pdata->ctrl_mod_reg_offset  = AM35XX_EMAC_CNTRL_MOD_OFFSET;
+	pdata->ctrl_ram_offset      = AM35XX_EMAC_CNTRL_RAM_OFFSET;
+	pdata->ctrl_ram_size        = AM35XX_EMAC_CNTRL_RAM_SIZE;
+	pdata->version              = EMAC_VERSION_2;
+	pdata->hw_ram_addr          = AM35XX_EMAC_HW_RAM_ADDR;
+	pdata->interrupt_enable     = pia35x_enable_ethernet_int;
+	pdata->interrupt_disable    = pia35x_disable_ethernet_int;
+	pia35x_emac_device.dev.platform_data = pdata;
+	platform_device_register(&pia35x_mdio_device);
+	platform_device_register(&pia35x_emac_device);
+	clk_add_alias(NULL, dev_name(&pia35x_mdio_device.dev),
+		      NULL, &pia35x_emac_device.dev);
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);
+	regval = regval & (~(AM35XX_CPGMACSS_SW_RST));
+	omap_ctrl_writel(regval, AM35XX_CONTROL_IP_SW_RESET);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);
+
+	return ;
+}
+
+/*
+ * GSM
+ */
+static int __init pia35x_gsm_init(void)
+{
+	int ret;
+	//omap_mux_init_gpio(29, OMAP_PIN_OUTPUT);
+	if ((ret = gpio_request(29, "GSM_Power")))
+		pr_warning("%s: GPIO 29 request failed: %d\n", __func__, ret);
+	gpio_export(29, 1);
+	gpio_direction_output(29, 1);
+
+	//omap_mux_init_gpio(126, OMAP_PIN_OUTPUT);
+	if ((ret = gpio_request(126,"GSM_Reset")))
+		pr_warning("%s: GPIO 126 request failed: %d\n", __func__, ret);
+	gpio_export(126, 1);
+	gpio_direction_output(126, 1);
+
+	//omap_mux_init_gpio(127, OMAP_PIN_OUTPUT);
+	if ((ret = gpio_request(127,"GSM_On/Off")))
+		pr_warning("%s: GPIO 127 request failed, %d\n", __func__, ret);
+	gpio_export(127, 1);
+	gpio_direction_output(127, 1);
+
+	return 0;
+}
+
+
+/*
+ * CAN - HECC
+ */
+//#define CAN_STB         214
+//static void hecc_phy_control(int on)
+//{
+//        int r;
+//
+//        r = gpio_request(CAN_STB, "can_stb");
+//        if (r) {
+//                printk(KERN_ERR "failed to get can_stb \n");
+//                return;
+//        }
+//
+//        gpio_direction_output(CAN_STB, (on==1)?0:1);
+//}
+
+static struct resource pia35x_hecc_resources[] = {
+	{
+		.start	= AM35XX_IPSS_HECC_BASE,
+		.end	= AM35XX_IPSS_HECC_BASE + 0x3FFF,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= INT_35XX_HECC0_IRQ,
+		.end	= INT_35XX_HECC0_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device pia35x_hecc_device = {
+	.name           = "ti_hecc",
+	.id	            = -1,
+	.num_resources  = ARRAY_SIZE(pia35x_hecc_resources),
+	.resource       = pia35x_hecc_resources,
+};
+
+static struct ti_hecc_platform_data pia35x_hecc_pdata = {
+	.scc_hecc_offset = AM35XX_HECC_SCC_HECC_OFFSET,
+	.scc_ram_offset  = AM35XX_HECC_SCC_RAM_OFFSET,
+	.hecc_ram_offset = AM35XX_HECC_RAM_OFFSET,
+	.mbx_offset      = AM35XX_HECC_MBOX_OFFSET,
+	.int_line        = AM35XX_HECC_INT_LINE,
+	.version         = AM35XX_HECC_VERSION,
+	//.transceiver_switch     = hecc_phy_control,
+};
+
+static void __init pia35x_can_init(struct ti_hecc_platform_data *pdata)
+{
+	pia35x_hecc_device.dev.platform_data = pdata;
+	platform_device_register(&pia35x_hecc_device);
+}
+
+/*
+ * MMC
+ */
+/* MMC1 has fixed power supply */
+static struct regulator_consumer_supply pia35x_vmmc1_consumers[] = {
+		REGULATOR_SUPPLY("vmmc1", "mmci-omap-hs.0"),
+};
+
+static struct regulator_init_data pia35x_vmmc1_data = {
+	.constraints = {
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on		  = 1,
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(pia35x_vmmc1_consumers),
+	.consumer_supplies	    = pia35x_vmmc1_consumers,
+};
+
+static struct fixed_voltage_config pia35x_vmmc1_config = {
+	.supply_name     = "vmmc1",
+	.microvolts      = 3300000,  /* 3.3V */
+	.gpio            = -EINVAL,
+	//.enabled_at_boot = 1,
+	.init_data       = &pia35x_vmmc1_data,
+};
+
+static struct platform_device pia35x_vmmc1_device = {
+	.name           = "reg-fixed-voltage",
+	.id             = 1,
+	.dev = {
+		.platform_data = &pia35x_vmmc1_config,
+	},
+};
+
+
+/*
+ * Voltage Regulator
+ */
+#if defined(CONFIG_REGULATOR_TPS6507X)
+static struct tps6507x_reg_platform_data pia35x_tps_vdd2_platform_data = {
+		.defdcdc_default = true,
+};
+
+static struct tps6507x_reg_platform_data pia35x_tps_vdd3_platform_data = {
+		.defdcdc_default = false,
+};
+
+static struct regulator_consumer_supply pia35x_vdd1_consumers[] = {
+	{
+		.supply = "vdds",
+	},
+};
+
+static struct regulator_consumer_supply pia35x_vdd2_consumers[] = {
+	{
+		.supply = "vddshv",
+	},
+};
+
+static struct regulator_consumer_supply pia35x_vdd3_consumers[] = {
+	{
+		.supply = "vdd_core",
+	},
+};
+
+static struct regulator_consumer_supply pia35x_ldo1_consumers[] = {
+	{
+		.supply = "vdda1p8v_usbphy",
+	},
+};
+
+static struct regulator_consumer_supply pia35x_vpll_consumers[] = {
+	{
+		.supply = "vdds_dpll_mpu_usbhost",
+	},
+	{
+		.supply = "vdds_dpll_per_core",
+	},
+	{
+		.supply = "vdd_sram_mpu",
+	},
+	{
+		.supply = "vdd_sram_core_bg0",
+	},
+	{
+		.supply = "vddsosc",
+	},
+};
 
+/* regulator_init_data for the outputs are organized in an array
+ * [0]: VDCDC1  1.8V VDDS_1V8
+ * [1]: VDCDC2  3.3V VDDSHV_3V3
+ * [2]: VDCDC3  1.2V VDDCORE_1V2     (cpu core)
+ * [3]: VLDO1   1.8V VDDA1P8V_USBPHY (usb)
+ * [4]: VLDO2   1.8V VDDS_DPLL_1V8   (pll)
+ */
+static struct regulator_init_data pia35x_tps_regulator_data[] = {
+		/* dcdc: VDDS_1V8*/
+		{
+				.constraints = {
+						.min_uV = 1800000,
+						.max_uV = 1800000,
+						.valid_modes_mask = REGULATOR_MODE_NORMAL,
+						.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+						.always_on = true,
+						.apply_uV = true,
+				},
+				.num_consumer_supplies = ARRAY_SIZE(pia35x_vdd1_consumers),
+				.consumer_supplies     = &pia35x_vdd1_consumers[0],
+		},
+		/* dcdc2: VDDSHV_3V3 */
+		{
+				.constraints = {
+						.min_uV = 3300000,
+						.max_uV = 3300000,
+						.valid_modes_mask = REGULATOR_MODE_NORMAL,
+						.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+						.always_on = true,
+						.apply_uV = true
+				},
+				.num_consumer_supplies = ARRAY_SIZE(pia35x_vdd2_consumers),
+				.consumer_supplies = &pia35x_vdd2_consumers[0],
+				/* select high = 3.3V (low is 1.8) */
+				.driver_data = &pia35x_tps_vdd2_platform_data,
+		},
+		/* dcdc3: VDDCORE_1V2 */
+		{
+				.constraints = {
+						.min_uV = 1200000,
+						.max_uV = 1200000,
+						.valid_modes_mask = REGULATOR_MODE_NORMAL,
+						.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+						.always_on = true,
+						.apply_uV = true
+				},
+				.num_consumer_supplies = ARRAY_SIZE(pia35x_vdd3_consumers),
+				.consumer_supplies = &pia35x_vdd3_consumers[0],
+				/* select low = 1.2V (high is 1.35) */
+				.driver_data = &pia35x_tps_vdd3_platform_data,
+		},
+		/* ldo1: VDDA1P8V_USBPHY */
+		{
+				.constraints = {
+						.min_uV           = 1800000,
+						.max_uV           = 1800000,
+						.valid_modes_mask = REGULATOR_MODE_NORMAL,
+						.valid_ops_mask   = REGULATOR_CHANGE_STATUS,
+						//.boot_on = 1,
+						.always_on = true,
+						.apply_uV = true,
+				},
+				.num_consumer_supplies = ARRAY_SIZE(pia35x_ldo1_consumers),
+				.consumer_supplies = &pia35x_ldo1_consumers[0],
+		},
+		/* ldo2: VDDS_DPLL_1V8 */
+		{
+				.constraints = {
+						.min_uV           = 1800000,
+						.max_uV           = 1800000,
+						.valid_modes_mask = REGULATOR_MODE_NORMAL,
+						.valid_ops_mask   = REGULATOR_CHANGE_STATUS,
+						//.boot_on = 1,
+						.always_on = true,
+						.apply_uV = true,
+				},
+				.num_consumer_supplies = ARRAY_SIZE(pia35x_vpll_consumers),
+				.consumer_supplies = &pia35x_vpll_consumers[0],
+		},
+};
+
+static struct tps6507x_board pia35x_tps_board = {
+		/* regulator */
+		.tps6507x_pmic_init_data = &pia35x_tps_regulator_data[0],
+		.tps6507x_ts_init_data   = 0,   /* no touchscreen */
+};
+
+/* register our voltage regulator TPS650732 using I2C1 */
+static int __init pia35x_pmic_tps65070_init(void)
+{
+	// does nothing, already registered with i2c inits
+	return 0;
+}
+#endif /* CONFIG_REGULATOR_TPS6507X */
+
+/*
+ * MMC1
+ */
+static struct omap2_hsmmc_info mmc[] = {
+	/* first MMC port used for system MMC modules */
+	{
+		.mmc            = 1,
+		.caps           = MMC_CAP_4_BIT_DATA,
+		.gpio_cd        = 41,
+		.gpio_wp        = -EINVAL, /* we don't have a WP pin connected, was: 40 */
+		//.ocr_mask       = MMC_VDD_33_34,
+	},
+#if defined(CONFIG_WL1271) || defined (CONFIG_WL1271_MODULE)
+	{
+		.name		= "wl1271",
+		.mmc		= 2,
+		.caps		= MMC_CAP_4_BIT_DATA | MMC_CAP_POWER_OFF_CARD,
+		.gpio_wp	= -EINVAL,
+		.gpio_cd	= -EINVAL,
+		.nonremovable	= true,
+		.ext_clock  = false,
+		//.ocr_mask   = MMC_VDD_165_195 | MMC_VDD_33_34,
+	},
+#endif /* CONFIG_WL12XX_PLATFORM_DATA */
+	{}	/* Terminator */
+};
+
+static void __init pia35x_mmc_init(void)
+{
+	pr_info("piA-am35x: registering VMMC1 platform device\n");
+	/* handling of different MMC2 expansions here */
+	omap2_hsmmc_init(mmc);
+	/* link regulator to on-board MMC adapter */
+	//TODO pia35x_vmmc1_consumers[0].dev = mmc[0].dev;
+	platform_device_register(&pia35x_vmmc1_device);
+}
+
+/*
+ * external WLAN WL1271
+ */
+#define PIA35X_WLAN_IRQ_GPIO	137
+#define PIA35X_WLAN_PMENA_GPIO	139
+#define PIA35X_BT_EN_GPIO       138
+
+static struct regulator_consumer_supply pia35x_vmmc2_supply =
+		REGULATOR_SUPPLY("vmmc", "mmci-omap-hs.1");
+//		{
+//				.supply = "vmmc",
+//		}
+
+
+static struct regulator_init_data pia35x_vmmc2_data = {
+	.constraints = {
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.min_uV         = 1800000,//3300000,
+		.max_uV         = 1800000,//3300000,
+		.apply_uV       = true,
+		.always_on		= true,
+	},
+	.num_consumer_supplies	= 1, //ARRAY_SIZE(pia35x_vmmc2_consumers),
+	.consumer_supplies	    = &pia35x_vmmc2_supply,
+};
+
+static struct fixed_voltage_config pia35x_vmmc2_config = {
+	.supply_name     = "vwl1271",
+	.microvolts      = 1800000, // 3300000,  /* 3.3V */
+	.gpio            = PIA35X_WLAN_PMENA_GPIO,
+	.startup_delay   = 70000,
+	.enable_high     = 1,	/* gpio = 1 means wlan_en active */
+	.enabled_at_boot = 0,	/* was the module enabled before linux boot */
+	.init_data       = &pia35x_vmmc2_data,
+};
+
+static struct platform_device pia35x_vwlan_device = {
+	.name           = "reg-fixed-voltage",
+	.id             = 2,
+	.dev = {
+		.platform_data = &pia35x_vmmc2_config,
+	},
+};
+
+#define WL12XX_REFCLOCK_26      1 /* 26 MHz */
+#define WL12XX_REFCLOCK_38      2 /* 38.4 MHz */
+
+struct wl12xx_platform_data pia35x_wlan_data __initdata = {
+	.irq = OMAP_GPIO_IRQ(PIA35X_WLAN_IRQ_GPIO),
+	/* internal ref clock is 38 MHz */
+	.board_ref_clock = WL12XX_REFCLOCK_38, /* 2, internal refclock of the  */
+};
+
+static int __init pia35x_wlan_init(void)
+{
+	u32 reg;
+	if (wl12xx_set_platform_data(&pia35x_wlan_data))
+		pr_err("%s: error setting wl12xx data\n", __func__);
+
+	// we need to enable the internal clock loopback on MMC2!
+	reg = omap_ctrl_readl(OMAP343X_CONTROL_DEVCONF1);
+	reg |= OMAP2_MMCSDIO2ADPCLKISEL;
+	omap_ctrl_writel(reg, OMAP343X_CONTROL_DEVCONF1);
+
+//	omap_mux_init_gpio(PIA35X_WLAN_IRQ_GPIO, OMAP_PIN_OUTPUT);
+//	if (gpio_request(PIA35X_WLAN_IRQ_GPIO, "wlan.irq"))
+//		pr_warning("GPIO 137 (WLAN.IRQ) request failed\n");
+//	//gpio_export(PIA35X_WLAN_IRQ_GPIO, 1);
+//	gpio_direction_input(PIA35X_WLAN_IRQ_GPIO);
+
+//	omap_mux_init_gpio(PIA35X_WLAN_PMENA_GPIO, OMAP_PIN_OUTPUT);
+//	if (gpio_request(PIA35X_WLAN_PMENA_GPIO, "wlan.en")) {
+//		pr_warning("GPIO 139 (WLAN.EN) request failed\n");
+//	} else {
+//		gpio_direction_output(PIA35X_WLAN_PMENA_GPIO, 1);
+//	}
+//	gpio_free(PIA35X_WLAN_PMENA_GPIO);
+//	msleep(50);
+	//gpio_export(139, 1);
+	//gpio_direction_output(139, 1);
+
+	//omap_mux_init_signal("sdmmc2_dat5.gpio_137", OMAP_PIN_INPUT_PULLUP);
+	//omap_mux_init_signal("sdmmc2_dat7.gpio_139", OMAP_PIN_OUTPUT);
+	//pia35x_vmmc2_consumers[0].dev = mmc[1].dev;
+
+	platform_device_register(&pia35x_vwlan_device);
+
+	return 0;
+}
+
+/*
+ * BT
+ */
+static void __init pia35x_bt_init(void)
+{
+	/* just enable the BT module */
+	if (gpio_request(PIA35X_BT_EN_GPIO, "bt.en")) {
+		pr_warning("GPIO 138 (BT.EN) request failed\n");
+	} else {
+		gpio_direction_output(PIA35X_BT_EN_GPIO, 1);
+	}
+}
+
+/*
+ * MUSB (USB OTG)
+ */
+static struct omap_musb_board_data pia35x_musb_board_data = {
+	.interface_type         = MUSB_INTERFACE_ULPI,
+	.mode                   = MUSB_OTG,
+	.power                  = 500,
+};
+
+static __init void pia35x_musb_init(void)
+{
+	u32 devconf2;
+
+	/*
+	 * Set up USB clock/mode in the DEVCONF2 register.
+	 */
+	devconf2 = omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2);
+
+	/* USB2.0 PHY reference clock is 13 MHz */
+	devconf2 &= ~(CONF2_REFFREQ | CONF2_OTGMODE | CONF2_PHY_GPIOMODE);
+	devconf2 |=  CONF2_REFFREQ_13MHZ | CONF2_SESENDEN | CONF2_VBDTCTEN
+			| CONF2_DATPOL;
+
+	omap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);
+
+	usb_musb_init(&pia35x_musb_board_data);
+}
+
+/*
+ * NAND
+ * we use GPMC CS 0
+ */
+#define PIA35X_NAND_CS 0
+static struct mtd_partition pia35x_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name           = "xloader-nand",
+		.offset         = 0,
+		.size           = 4*(SZ_128K),
+		.mask_flags     = MTD_WRITEABLE
+	},
+	{
+		.name           = "uboot-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 28*(SZ_128K),
+		.mask_flags     = MTD_WRITEABLE
+	},
+	{
+		.name           = "params-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 4*(SZ_128K)
+	},
+	{
+		.name           = "linux-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 80*(SZ_128K)
+	},
+	{
+		.name           = "jffs2-nand",
+		.size           = MTDPART_SIZ_FULL,
+		.offset         = MTDPART_OFS_APPEND,
+	},
+};
+
+#if 0 /* we don't need this in 2.6.37 */
+static struct omap_nand_platform_data am3517crane_nand_data = {
+	.parts          = pia35x_nand_partitions,
+	.nr_parts       = ARRAY_SIZE(pia35x_nand_partitions),
+	.nand_setup     = NULL,
+	.dma_channel    = -1,           /* disable DMA in OMAP NAND driver */
+	.dev_ready      = NULL,
+};
+
+static struct resource am3517crane_nand_resource = {
+	.flags          = IORESOURCE_MEM,
+};
+
+static struct platform_device am3517crane_nand_device = {
+	.name           = "omap2-nand",
+	.id             = 0,
+	.dev            = {
+		.platform_data  = &am3517crane_nand_data,
+	},
+	.num_resources  = 1,
+	.resource       = &am3517crane_nand_resource,
+};
+#endif /* 0 */
+
+static void __init pia35x_flash_init(void)
+{
+#if 0 /* we don't need this in 2.6.37 */
+	u8 cs = 0;
+	u8 nandcs = GPMC_CS_NUM + 1;
+	u32 gpmc_base_add = OMAP34XX_GPMC_VIRT;
+
+	while (cs < GPMC_CS_NUM) {
+		u32 ret = 0;
+		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
+
+		if ((ret & 0xC00) == 0x800) {
+			/* Found it!! */
+			if (nandcs > GPMC_CS_NUM)
+				nandcs = cs;
+		}
+		cs++;
+	}
+	if (nandcs > GPMC_CS_NUM) {
+		printk(KERN_INFO "NAND: Unable to find configuration "
+				" in GPMC\n ");
+		return;
+	}
+
+	if (nandcs < GPMC_CS_NUM) {
+		board_nand_init(pia35x_nand_partitions,
+				ARRAY_SIZE(pia35x_nand_partitions), nandcs, NAND_BUSWIDTH_16);
+//		am3517crane_nand_data.cs   = nandcs;
+//		am3517crane_nand_data.gpmc_cs_baseaddr =
+//		(void *)(gpmc_base_add + GPMC_CS0_BASE + nandcs*GPMC_CS_SIZE);
+//
+//		am3517crane_nand_data.gpmc_baseaddr = (void *)(gpmc_base_add);
+//
+//		if (platform_device_register(&am3517crane_nand_device) < 0)
+//			printk(KERN_ERR "Unable to register NAND device\n");
+
+	}
+#endif /* 0 - old nand detection */
+	board_nand_init(pia35x_nand_partitions,
+			ARRAY_SIZE(pia35x_nand_partitions),
+			PIA35X_NAND_CS, NAND_BUSWIDTH_16);
+}
+
+/*
+ * I2C
+ */
+static struct i2c_board_info __initdata pia35x_i2c1_info[] = {
+#if defined(CONFIG_REGULATOR_TPS6507X)
+		/* power regulator TPS650732 */
+		{
+				I2C_BOARD_INFO("tps6507x", 0x48),
+				.flags = I2C_CLIENT_WAKE,
+				.irq = INT_34XX_SYS_NIRQ,
+				.platform_data = &pia35x_tps_board,
+		},
+#endif /* CONFIG_REGULATOR_TPS6507X */
+		/* RTC + WDOG */
+		{
+				I2C_BOARD_INFO("ds1374", 0x68),
+		},
+
+};
+
+static struct i2c_board_info __initdata pia35x_i2c2_info[] = {
+		/* temperature sensor LM75 */
+		{
+				I2C_BOARD_INFO("lm75", 0x48),
+		},
+};
+
+static struct i2c_board_info __initdata pia35x_i2c3_info[] = {
+};
+
+static int __init pia35x_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 400, pia35x_i2c1_info, ARRAY_SIZE(pia35x_i2c1_info));
+	omap_register_i2c_bus(2, 400, pia35x_i2c2_info, ARRAY_SIZE(pia35x_i2c2_info));
+	omap_register_i2c_bus(3, 400, pia35x_i2c3_info, ARRAY_SIZE(pia35x_i2c3_info));
+
+	return 0;
+}
+
+static void __init am3517_crane_init_irq(void)
+{
+	omap_board_config = am3517_crane_config;
+	omap_board_config_size = ARRAY_SIZE(am3517_crane_config);
+
+	omap2_init_common_infrastructure();
+	omap2_init_common_devices(NULL, NULL);
+	omap_init_irq();
+	gpmc_init();
+}
+
+/*
+ * base initialisation function
+ */
 static void __init am3517_crane_init(void)
 {
 	int ret;
 
-	omap3_mux_init(board_mux, OMAP_PACKAGE_CBB);
+	pr_info("pia35x_init: init pin muc\n");
+	ret = omap3_mux_init(board_mux, OMAP_PACKAGE_CBB);
+	if (ret)
+		pr_warning("pia35x_init: MUX init failed: %d\n", ret);
+
+	pr_info("pia35x_init: init I2C busses\n");
+	pia35x_i2c_init();
+
+	pr_info("pia35x_init: init serial ports\n");
 	omap_serial_init();
 
+	pr_info("pia35x_init: init NAND\n");
+	pia35x_flash_init();
+
+	pr_info("pia35x_init: init USB OTG\n");
+	pia35x_musb_init();
+
+	pr_info("pia35x_init: init ETH\n");
+	pia35x_ethernet_init(&pia35x_emac_pdata);
+	pr_info("pia35x_init: init CAN\n");
+	pia35x_can_init(&pia35x_hecc_pdata);
+
+	pr_info("pia35x_init: init MMC\n");
+	pia35x_mmc_init();
+
+	pr_info("pia35x_init: init WLAN & BT\n");
+	pia35x_wlan_init();
+	pia35x_bt_init();
+
+	pr_info("pia35x_init: init GSM\n");
+	pia35x_gsm_init();
+
+	/* TODO
+	 * WLAN
+	 * bluetooth
+	 * display?
+	 */
+
+#ifdef NOT_USED
 	/* Configure GPIO for EHCI port */
 	if (omap_mux_init_gpio(GPIO_USB_NRESET, OMAP_PIN_OUTPUT)) {
 		pr_err("Can not configure mux for GPIO_USB_NRESET %d\n",
@@ -104,13 +932,15 @@ static void __init am3517_crane_init(void)
 	}
 
 	usb_ehci_init(&ehci_pdata);
+#endif
+
 }
 
 MACHINE_START(CRANEBOARD, "AM3517/05 CRANEBOARD")
-	.boot_params	= 0x80000100,
-	.map_io		= omap3_map_io,
-	.reserve	= omap_reserve,
-	.init_irq	= am3517_crane_init_irq,
-	.init_machine	= am3517_crane_init,
-	.timer		= &omap_timer,
+	.boot_params  = 0x80000100,
+	.map_io       = omap3_map_io,
+	.reserve      = omap_reserve,
+	.init_irq     = am3517_crane_init_irq,
+	.init_machine = am3517_crane_init,
+	.timer		  = &omap_timer,
 MACHINE_END
diff --git a/arch/arm/mach-omap2/board-am35xpia.c b/arch/arm/mach-omap2/board-am35xpia.c
new file mode 100644
index 0000000..bb1cfbd
--- /dev/null
+++ b/arch/arm/mach-omap2/board-am35xpia.c
@@ -0,0 +1,946 @@
+/*
+ * Support for AM3505 piA
+ * by pironex GmbH -- http://www.pironex.de
+ *
+ * Copyright (C) 2011 pironex GmbH <info@pironex.de>
+ * Author: Bjoern Krombholz <b.krombholz@pironex.de>
+ *
+ * Ideas taken from mach-omap2/board-am3517crane.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as  published by the
+ * Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/davinci_emac.h>
+#include <linux/gpio.h>
+#include <linux/mfd/tps6507x.h>
+#include <linux/mmc/host.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/tps6507x.h>
+#include <linux/regulator/fixed.h>
+#include <linux/wl12xx.h>
+#include <linux/can/platform/ti_hecc.h>
+
+#include <mach/hardware.h>
+#include <mach/am35xx.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <plat/board.h>
+#include <plat/common.h>
+#include <plat/gpmc.h>
+#include <plat/nand.h>
+#include <plat/usb.h>
+
+#include "mux.h"
+#include "control.h"
+#include "hsmmc.h"
+#include "board-flash.h"
+
+/* Board initialization */
+static struct omap_board_config_kernel am3517_crane_config[] __initdata = {
+};
+
+#ifdef CONFIG_OMAP_MUX
+static struct omap_board_mux board_mux[] __initdata = {
+		/* only fixed MUXes here, don't add anything on expansions */
+
+		/* MMC1_CD        GPIO 041, low == card in slot */
+		OMAP3_MUX(GPMC_A8, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLUP),
+
+		/* EN_GSM_POWER   GPIO 029, low active */
+		OMAP3_MUX(ETK_D15,     OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+		/* GSM_nRESET     GPIO 126, low active */
+		OMAP3_MUX(SDMMC1_DAT4, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+		/* nGSM_ON/OFF    GPIO 127, low active */
+		OMAP3_MUX(SDMMC1_DAT5, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+
+		/* UART2.485/#232 GPIO 128, low = RS232 */
+		OMAP3_MUX(SDMMC1_DAT6, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+		/* UART2.SLEW     GPIO 129 */
+		OMAP3_MUX(SDMMC1_DAT7, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+
+		/* undocumented */
+		//OMAP3_MUX(CHASSIS_DMAREQ3, OMAP_MUX_MODE0 | OMAP_PIN_INPUT_PULLDOWN),
+		/* MCBSP_CLKS     GPIO 160 */
+		//OMAP3_MUX(MCBSP_CLKS, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLUP),
+
+		/* INPUT_GPIO1    GPIO 055 */
+		OMAP3_MUX(GPMC_NCS4, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLUP),
+		/* INPUT_GPIO2    GPIO 056 */
+		OMAP3_MUX(GPMC_NCS5, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLUP),
+
+		/* ETHERNET_nRST  GPIO 065 */
+		OMAP3_MUX(GPMC_WAIT3, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),
+
+		/* WLAN.EN        GPIO 139 */
+		OMAP3_MUX(SDMMC2_DAT7, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLDOWN/* OMAP_PIN_OUTPUT*/),
+		/* BT.EN          GPIO 138 */
+		OMAP3_MUX(SDMMC2_DAT6, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLDOWN/*OMAP_PIN_OUTPUT*/),
+		/* WLAN.IRQ       GPIO 137 */
+		OMAP3_MUX(SDMMC2_DAT5, OMAP_MUX_MODE4 | OMAP_PIN_INPUT),
+		/*        GPIO 136 */
+		OMAP3_MUX(SDMMC2_DAT5, OMAP_MUX_MODE4 | OMAP_PIN_INPUT/*OMAP_PIN_OUTPUT*/),
+		/* TERMINATOR */
+		{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#else
+#define board_mux	NULL
+#endif
+
+#if 0 /* USB EHCI port only on expansion port */
+static struct ehci_hcd_omap_platform_data ehci_pdata __initdata = {
+	.port_mode[0] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[1] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+	.port_mode[2] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+
+	.phy_reset  = true,
+	.reset_gpio_port[0]  = -EINVAL,
+	.reset_gpio_port[1]  = -EINVAL,
+	.reset_gpio_port[2]  = -EINVAL
+};
+#endif
+
+/*
+ * Ethernet (internal) & PHY (SMSC LAN8720A-CP)
+ */
+#define GPIO_ETHERNET_NRST 65
+#define AM35XX_EVM_MDIO_FREQUENCY	(1000000)
+
+static struct mdio_platform_data pia35x_evm_mdio_pdata = {
+	.bus_freq	= AM35XX_EVM_MDIO_FREQUENCY,
+};
+
+static struct resource pia35x_mdio_resources[] = {
+	{
+		.start  = AM35XX_IPSS_EMAC_BASE + AM35XX_EMAC_MDIO_OFFSET,
+		.end    = AM35XX_IPSS_EMAC_BASE + AM35XX_EMAC_MDIO_OFFSET +
+			  SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device pia35x_mdio_device = {
+	.name		= "davinci_mdio",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(pia35x_mdio_resources),
+	.resource	= pia35x_mdio_resources,
+	.dev.platform_data = &pia35x_evm_mdio_pdata,
+};
+
+static struct emac_platform_data pia35x_emac_pdata = {
+	.rmii_en	= 1,
+};
+
+static struct resource pia35x_emac_resources[] = {
+	{
+		.start  = AM35XX_IPSS_EMAC_BASE,
+		.end    = AM35XX_IPSS_EMAC_BASE + 0x2FFFF,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_RXTHRESH_IRQ,
+		.end    = INT_35XX_EMAC_C0_RXTHRESH_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_RX_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_RX_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_TX_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_TX_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_MISC_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_MISC_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device pia35x_emac_device = {
+	.name           = "davinci_emac",
+	.id	            = -1,
+	.num_resources  = ARRAY_SIZE(pia35x_emac_resources),
+	.resource       = pia35x_emac_resources,
+};
+
+/*
+ * initialize MAC address from boot parameter eth=<MAC>
+ */
+static int __init eth_addr_setup(char *str)
+{
+	int i;
+
+	if (str == NULL)
+		return 0;
+	for (i = 0; i < ETH_ALEN; i++)
+		pia35x_emac_pdata.mac_addr[i] = simple_strtol(&str[i*3],
+				(char **)NULL, 16);
+	return 1;
+}
+/* Get MAC address from kernel boot parameter eth=AA:BB:CC:DD:EE:FF */
+__setup("eth=", eth_addr_setup);
+
+/*
+ * disable ETH interrupt
+ */
+static void pia35x_enable_ethernet_int(void)
+{
+	u32 regval;
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = (regval | AM35XX_CPGMAC_C0_RX_PULSE_CLR |
+			AM35XX_CPGMAC_C0_TX_PULSE_CLR |
+			AM35XX_CPGMAC_C0_MISC_PULSE_CLR |
+			AM35XX_CPGMAC_C0_RX_THRESH_CLR);
+	omap_ctrl_writel(regval, AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+}
+
+/*
+ * enable ETH interrupt
+ */
+static void pia35x_disable_ethernet_int(void)
+{
+	u32 regval;
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = (regval | AM35XX_CPGMAC_C0_RX_PULSE_CLR |
+		AM35XX_CPGMAC_C0_TX_PULSE_CLR);
+	omap_ctrl_writel(regval, AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+}
+
+/*
+ * ETH init
+ * make sure ETH module is powered
+ * initialize MAC, PHY and configurationn
+ */
+static void __init pia35x_ethernet_init(struct emac_platform_data *pdata)
+{
+	u32 regval, mac_lo, mac_hi;
+
+	/* unset reset */
+	gpio_request(GPIO_ETHERNET_NRST, "ethernet-nrst");
+	gpio_direction_output(GPIO_ETHERNET_NRST, 1);
+	msleep(50);
+
+	mac_lo = omap_ctrl_readl(AM35XX_CONTROL_FUSE_EMAC_LSB);
+	mac_hi = omap_ctrl_readl(AM35XX_CONTROL_FUSE_EMAC_MSB);
+
+	pdata->mac_addr[0] = (u_int8_t)((mac_hi & 0xFF0000) >> 16);
+	pdata->mac_addr[1] = (u_int8_t)((mac_hi & 0xFF00)   >> 8);
+	pdata->mac_addr[2] = (u_int8_t)((mac_hi & 0xFF)     >> 0);
+	pdata->mac_addr[3] = (u_int8_t)((mac_lo & 0xFF0000) >> 16);
+	pdata->mac_addr[4] = (u_int8_t)((mac_lo & 0xFF00)   >> 8);
+	pdata->mac_addr[5] = (u_int8_t)((mac_lo & 0xFF)     >> 0);
+
+	pdata->ctrl_reg_offset      = AM35XX_EMAC_CNTRL_OFFSET;
+	pdata->ctrl_mod_reg_offset  = AM35XX_EMAC_CNTRL_MOD_OFFSET;
+	pdata->ctrl_ram_offset      = AM35XX_EMAC_CNTRL_RAM_OFFSET;
+	pdata->ctrl_ram_size        = AM35XX_EMAC_CNTRL_RAM_SIZE;
+	pdata->version              = EMAC_VERSION_2;
+	pdata->hw_ram_addr          = AM35XX_EMAC_HW_RAM_ADDR;
+	pdata->interrupt_enable     = pia35x_enable_ethernet_int;
+	pdata->interrupt_disable    = pia35x_disable_ethernet_int;
+	pia35x_emac_device.dev.platform_data = pdata;
+	platform_device_register(&pia35x_mdio_device);
+	platform_device_register(&pia35x_emac_device);
+	clk_add_alias(NULL, dev_name(&pia35x_mdio_device.dev),
+		      NULL, &pia35x_emac_device.dev);
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);
+	regval = regval & (~(AM35XX_CPGMACSS_SW_RST));
+	omap_ctrl_writel(regval, AM35XX_CONTROL_IP_SW_RESET);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);
+
+	return ;
+}
+
+/*
+ * GSM
+ */
+static int __init pia35x_gsm_init(void)
+{
+	int ret;
+	//omap_mux_init_gpio(29, OMAP_PIN_OUTPUT);
+	if ((ret = gpio_request(29, "GSM_Power")))
+		pr_warning("%s: GPIO 29 request failed: %d\n", __func__, ret);
+	gpio_export(29, 1);
+	gpio_direction_output(29, 1);
+
+	//omap_mux_init_gpio(126, OMAP_PIN_OUTPUT);
+	if ((ret = gpio_request(126,"GSM_Reset")))
+		pr_warning("%s: GPIO 126 request failed: %d\n", __func__, ret);
+	gpio_export(126, 1);
+	gpio_direction_output(126, 1);
+
+	//omap_mux_init_gpio(127, OMAP_PIN_OUTPUT);
+	if ((ret = gpio_request(127,"GSM_On/Off")))
+		pr_warning("%s: GPIO 127 request failed, %d\n", __func__, ret);
+	gpio_export(127, 1);
+	gpio_direction_output(127, 1);
+
+	return 0;
+}
+
+
+/*
+ * CAN - HECC
+ */
+//#define CAN_STB         214
+//static void hecc_phy_control(int on)
+//{
+//        int r;
+//
+//        r = gpio_request(CAN_STB, "can_stb");
+//        if (r) {
+//                printk(KERN_ERR "failed to get can_stb \n");
+//                return;
+//        }
+//
+//        gpio_direction_output(CAN_STB, (on==1)?0:1);
+//}
+
+static struct resource pia35x_hecc_resources[] = {
+	{
+		.start	= AM35XX_IPSS_HECC_BASE,
+		.end	= AM35XX_IPSS_HECC_BASE + 0x3FFF,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= INT_35XX_HECC0_IRQ,
+		.end	= INT_35XX_HECC0_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device pia35x_hecc_device = {
+	.name           = "ti_hecc",
+	.id	            = -1,
+	.num_resources  = ARRAY_SIZE(pia35x_hecc_resources),
+	.resource       = pia35x_hecc_resources,
+};
+
+static struct ti_hecc_platform_data pia35x_hecc_pdata = {
+	.scc_hecc_offset = AM35XX_HECC_SCC_HECC_OFFSET,
+	.scc_ram_offset  = AM35XX_HECC_SCC_RAM_OFFSET,
+	.hecc_ram_offset = AM35XX_HECC_RAM_OFFSET,
+	.mbx_offset      = AM35XX_HECC_MBOX_OFFSET,
+	.int_line        = AM35XX_HECC_INT_LINE,
+	.version         = AM35XX_HECC_VERSION,
+	//.transceiver_switch     = hecc_phy_control,
+};
+
+static void __init pia35x_can_init(struct ti_hecc_platform_data *pdata)
+{
+	pia35x_hecc_device.dev.platform_data = pdata;
+	platform_device_register(&pia35x_hecc_device);
+}
+
+/*
+ * MMC
+ */
+/* MMC1 has fixed power supply */
+static struct regulator_consumer_supply pia35x_vmmc1_consumers[] = {
+		REGULATOR_SUPPLY("vmmc1", "mmci-omap-hs.0"),
+};
+
+static struct regulator_init_data pia35x_vmmc1_data = {
+	.constraints = {
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.always_on		  = 1,
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(pia35x_vmmc1_consumers),
+	.consumer_supplies	    = pia35x_vmmc1_consumers,
+};
+
+static struct fixed_voltage_config pia35x_vmmc1_config = {
+	.supply_name     = "vmmc1",
+	.microvolts      = 3300000,  /* 3.3V */
+	.gpio            = -EINVAL,
+	//.enabled_at_boot = 1,
+	.init_data       = &pia35x_vmmc1_data,
+};
+
+static struct platform_device pia35x_vmmc1_device = {
+	.name           = "reg-fixed-voltage",
+	.id             = 1,
+	.dev = {
+		.platform_data = &pia35x_vmmc1_config,
+	},
+};
+
+
+/*
+ * Voltage Regulator
+ */
+#if defined(CONFIG_REGULATOR_TPS6507X)
+static struct tps6507x_reg_platform_data pia35x_tps_vdd2_platform_data = {
+		.defdcdc_default = true,
+};
+
+static struct tps6507x_reg_platform_data pia35x_tps_vdd3_platform_data = {
+		.defdcdc_default = false,
+};
+
+static struct regulator_consumer_supply pia35x_vdd1_consumers[] = {
+	{
+		.supply = "vdds",
+	},
+};
+
+static struct regulator_consumer_supply pia35x_vdd2_consumers[] = {
+	{
+		.supply = "vddshv",
+	},
+};
+
+static struct regulator_consumer_supply pia35x_vdd3_consumers[] = {
+	{
+		.supply = "vdd_core",
+	},
+};
+
+static struct regulator_consumer_supply pia35x_ldo1_consumers[] = {
+	{
+		.supply = "vdda1p8v_usbphy",
+	},
+};
+
+static struct regulator_consumer_supply pia35x_vpll_consumers[] = {
+	{
+		.supply = "vdds_dpll_mpu_usbhost",
+	},
+	{
+		.supply = "vdds_dpll_per_core",
+	},
+	{
+		.supply = "vdd_sram_mpu",
+	},
+	{
+		.supply = "vdd_sram_core_bg0",
+	},
+	{
+		.supply = "vddsosc",
+	},
+};
+
+/* regulator_init_data for the outputs are organized in an array
+ * [0]: VDCDC1  1.8V VDDS_1V8
+ * [1]: VDCDC2  3.3V VDDSHV_3V3
+ * [2]: VDCDC3  1.2V VDDCORE_1V2     (cpu core)
+ * [3]: VLDO1   1.8V VDDA1P8V_USBPHY (usb)
+ * [4]: VLDO2   1.8V VDDS_DPLL_1V8   (pll)
+ */
+static struct regulator_init_data pia35x_tps_regulator_data[] = {
+		/* dcdc: VDDS_1V8*/
+		{
+				.constraints = {
+						.min_uV = 1800000,
+						.max_uV = 1800000,
+						.valid_modes_mask = REGULATOR_MODE_NORMAL,
+						.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+						.always_on = true,
+						.apply_uV = true,
+				},
+				.num_consumer_supplies = ARRAY_SIZE(pia35x_vdd1_consumers),
+				.consumer_supplies     = &pia35x_vdd1_consumers[0],
+		},
+		/* dcdc2: VDDSHV_3V3 */
+		{
+				.constraints = {
+						.min_uV = 3300000,
+						.max_uV = 3300000,
+						.valid_modes_mask = REGULATOR_MODE_NORMAL,
+						.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+						.always_on = true,
+						.apply_uV = true
+				},
+				.num_consumer_supplies = ARRAY_SIZE(pia35x_vdd2_consumers),
+				.consumer_supplies = &pia35x_vdd2_consumers[0],
+				/* select high = 3.3V (low is 1.8) */
+				.driver_data = &pia35x_tps_vdd2_platform_data,
+		},
+		/* dcdc3: VDDCORE_1V2 */
+		{
+				.constraints = {
+						.min_uV = 1200000,
+						.max_uV = 1200000,
+						.valid_modes_mask = REGULATOR_MODE_NORMAL,
+						.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+						.always_on = true,
+						.apply_uV = true
+				},
+				.num_consumer_supplies = ARRAY_SIZE(pia35x_vdd3_consumers),
+				.consumer_supplies = &pia35x_vdd3_consumers[0],
+				/* select low = 1.2V (high is 1.35) */
+				.driver_data = &pia35x_tps_vdd3_platform_data,
+		},
+		/* ldo1: VDDA1P8V_USBPHY */
+		{
+				.constraints = {
+						.min_uV           = 1800000,
+						.max_uV           = 1800000,
+						.valid_modes_mask = REGULATOR_MODE_NORMAL,
+						.valid_ops_mask   = REGULATOR_CHANGE_STATUS,
+						//.boot_on = 1,
+						.always_on = true,
+						.apply_uV = true,
+				},
+				.num_consumer_supplies = ARRAY_SIZE(pia35x_ldo1_consumers),
+				.consumer_supplies = &pia35x_ldo1_consumers[0],
+		},
+		/* ldo2: VDDS_DPLL_1V8 */
+		{
+				.constraints = {
+						.min_uV           = 1800000,
+						.max_uV           = 1800000,
+						.valid_modes_mask = REGULATOR_MODE_NORMAL,
+						.valid_ops_mask   = REGULATOR_CHANGE_STATUS,
+						//.boot_on = 1,
+						.always_on = true,
+						.apply_uV = true,
+				},
+				.num_consumer_supplies = ARRAY_SIZE(pia35x_vpll_consumers),
+				.consumer_supplies = &pia35x_vpll_consumers[0],
+		},
+};
+
+static struct tps6507x_board pia35x_tps_board = {
+		/* regulator */
+		.tps6507x_pmic_init_data = &pia35x_tps_regulator_data[0],
+		.tps6507x_ts_init_data   = 0,   /* no touchscreen */
+};
+
+/* register our voltage regulator TPS650732 using I2C1 */
+static int __init pia35x_pmic_tps65070_init(void)
+{
+	// does nothing, already registered with i2c inits
+	return 0;
+}
+#endif /* CONFIG_REGULATOR_TPS6507X */
+
+/*
+ * MMC1
+ */
+static struct omap2_hsmmc_info mmc[] = {
+	/* first MMC port used for system MMC modules */
+	{
+		.mmc            = 1,
+		.caps           = MMC_CAP_4_BIT_DATA,
+		.gpio_cd        = 41,
+		.gpio_wp        = -EINVAL, /* we don't have a WP pin connected, was: 40 */
+		//.ocr_mask       = MMC_VDD_33_34,
+	},
+#if defined(CONFIG_WL1271) || defined (CONFIG_WL1271_MODULE)
+	{
+		.name		= "wl1271",
+		.mmc		= 2,
+		.caps		= MMC_CAP_4_BIT_DATA | MMC_CAP_POWER_OFF_CARD,
+		.gpio_wp	= -EINVAL,
+		.gpio_cd	= -EINVAL,
+		.nonremovable	= true,
+		.ext_clock  = false,
+		//.ocr_mask   = MMC_VDD_165_195 | MMC_VDD_33_34,
+	},
+#endif /* CONFIG_WL12XX_PLATFORM_DATA */
+	{}	/* Terminator */
+};
+
+static void __init pia35x_mmc_init(void)
+{
+	pr_info("piA-am35x: registering VMMC1 platform device\n");
+	/* handling of different MMC2 expansions here */
+	omap2_hsmmc_init(mmc);
+	/* link regulator to on-board MMC adapter */
+	//TODO pia35x_vmmc1_consumers[0].dev = mmc[0].dev;
+	platform_device_register(&pia35x_vmmc1_device);
+}
+
+/*
+ * external WLAN WL1271
+ */
+#define PIA35X_WLAN_IRQ_GPIO	137
+#define PIA35X_WLAN_PMENA_GPIO	139
+#define PIA35X_BT_EN_GPIO       138
+
+static struct regulator_consumer_supply pia35x_vmmc2_supply =
+		REGULATOR_SUPPLY("vmmc", "mmci-omap-hs.1");
+//		{
+//				.supply = "vmmc",
+//		}
+
+
+static struct regulator_init_data pia35x_vmmc2_data = {
+	.constraints = {
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.min_uV         = 1800000,//3300000,
+		.max_uV         = 1800000,//3300000,
+		.apply_uV       = true,
+		.always_on		= true,
+	},
+	.num_consumer_supplies	= 1, //ARRAY_SIZE(pia35x_vmmc2_consumers),
+	.consumer_supplies	    = &pia35x_vmmc2_supply,
+};
+
+static struct fixed_voltage_config pia35x_vmmc2_config = {
+	.supply_name     = "vwl1271",
+	.microvolts      = 1800000, // 3300000,  /* 3.3V */
+	.gpio            = PIA35X_WLAN_PMENA_GPIO,
+	.startup_delay   = 70000,
+	.enable_high     = 1,	/* gpio = 1 means wlan_en active */
+	.enabled_at_boot = 0,	/* was the module enabled before linux boot */
+	.init_data       = &pia35x_vmmc2_data,
+};
+
+static struct platform_device pia35x_vwlan_device = {
+	.name           = "reg-fixed-voltage",
+	.id             = 2,
+	.dev = {
+		.platform_data = &pia35x_vmmc2_config,
+	},
+};
+
+#define WL12XX_REFCLOCK_26      1 /* 26 MHz */
+#define WL12XX_REFCLOCK_38      2 /* 38.4 MHz */
+
+static struct wl12xx_platform_data pia35x_wlan_data __initdata = {
+	.irq = OMAP_GPIO_IRQ(PIA35X_WLAN_IRQ_GPIO),
+	/* internal ref clock is 38 MHz */
+	.board_ref_clock = WL12XX_REFCLOCK_38, /* 2, internal refclock of the  */
+};
+
+static int __init pia35x_wlan_init(void)
+{
+	u32 reg;
+	if (wl12xx_set_platform_data(&pia35x_wlan_data))
+		pr_err("%s: error setting wl12xx data\n", __func__);
+
+	// we need to enable the internal clock loopback on MMC2!
+	reg = omap_ctrl_readl(OMAP343X_CONTROL_DEVCONF1);
+	reg |= OMAP2_MMCSDIO2ADPCLKISEL;
+	omap_ctrl_writel(reg, OMAP343X_CONTROL_DEVCONF1);
+
+//	omap_mux_init_gpio(PIA35X_WLAN_IRQ_GPIO, OMAP_PIN_OUTPUT);
+//	if (gpio_request(PIA35X_WLAN_IRQ_GPIO, "wlan.irq"))
+//		pr_warning("GPIO 137 (WLAN.IRQ) request failed\n");
+//	//gpio_export(PIA35X_WLAN_IRQ_GPIO, 1);
+//	gpio_direction_input(PIA35X_WLAN_IRQ_GPIO);
+
+//	omap_mux_init_gpio(PIA35X_WLAN_PMENA_GPIO, OMAP_PIN_OUTPUT);
+//	if (gpio_request(PIA35X_WLAN_PMENA_GPIO, "wlan.en")) {
+//		pr_warning("GPIO 139 (WLAN.EN) request failed\n");
+//	} else {
+//		gpio_direction_output(PIA35X_WLAN_PMENA_GPIO, 1);
+//	}
+//	gpio_free(PIA35X_WLAN_PMENA_GPIO);
+//	msleep(50);
+	//gpio_export(139, 1);
+	//gpio_direction_output(139, 1);
+
+	//omap_mux_init_signal("sdmmc2_dat5.gpio_137", OMAP_PIN_INPUT_PULLUP);
+	//omap_mux_init_signal("sdmmc2_dat7.gpio_139", OMAP_PIN_OUTPUT);
+	//pia35x_vmmc2_consumers[0].dev = mmc[1].dev;
+
+	platform_device_register(&pia35x_vwlan_device);
+
+	return 0;
+}
+
+/*
+ * BT
+ */
+static void __init pia35x_bt_init(void)
+{
+	/* just enable the BT module */
+	if (gpio_request(PIA35X_BT_EN_GPIO, "bt.en")) {
+		pr_warning("GPIO 138 (BT.EN) request failed\n");
+	} else {
+		gpio_direction_output(PIA35X_BT_EN_GPIO, 1);
+	}
+}
+
+/*
+ * MUSB (USB OTG)
+ */
+static struct omap_musb_board_data pia35x_musb_board_data = {
+	.interface_type         = MUSB_INTERFACE_ULPI,
+	.mode                   = MUSB_OTG,
+	.power                  = 500,
+};
+
+static __init void pia35x_musb_init(void)
+{
+	u32 devconf2;
+
+	/*
+	 * Set up USB clock/mode in the DEVCONF2 register.
+	 */
+	devconf2 = omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2);
+
+	/* USB2.0 PHY reference clock is 13 MHz */
+	devconf2 &= ~(CONF2_REFFREQ | CONF2_OTGMODE | CONF2_PHY_GPIOMODE);
+	devconf2 |=  CONF2_REFFREQ_13MHZ | CONF2_SESENDEN | CONF2_VBDTCTEN
+			| CONF2_DATPOL;
+
+	omap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);
+
+	usb_musb_init(&pia35x_musb_board_data);
+}
+
+/*
+ * NAND
+ * we use GPMC CS 0
+ */
+#define PIA35X_NAND_CS 0
+static struct mtd_partition pia35x_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name           = "xloader-nand",
+		.offset         = 0,
+		.size           = 4*(SZ_128K),
+		.mask_flags     = MTD_WRITEABLE
+	},
+	{
+		.name           = "uboot-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 28*(SZ_128K),
+		.mask_flags     = MTD_WRITEABLE
+	},
+	{
+		.name           = "params-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 4*(SZ_128K)
+	},
+	{
+		.name           = "linux-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 80*(SZ_128K)
+	},
+	{
+		.name           = "jffs2-nand",
+		.size           = MTDPART_SIZ_FULL,
+		.offset         = MTDPART_OFS_APPEND,
+	},
+};
+
+#if 0 /* we don't need this in 2.6.37 */
+static struct omap_nand_platform_data am3517crane_nand_data = {
+	.parts          = pia35x_nand_partitions,
+	.nr_parts       = ARRAY_SIZE(pia35x_nand_partitions),
+	.nand_setup     = NULL,
+	.dma_channel    = -1,           /* disable DMA in OMAP NAND driver */
+	.dev_ready      = NULL,
+};
+
+static struct resource am3517crane_nand_resource = {
+	.flags          = IORESOURCE_MEM,
+};
+
+static struct platform_device am3517crane_nand_device = {
+	.name           = "omap2-nand",
+	.id             = 0,
+	.dev            = {
+		.platform_data  = &am3517crane_nand_data,
+	},
+	.num_resources  = 1,
+	.resource       = &am3517crane_nand_resource,
+};
+#endif /* 0 */
+
+static void __init pia35x_flash_init(void)
+{
+#if 0 /* we don't need this in 2.6.37 */
+	u8 cs = 0;
+	u8 nandcs = GPMC_CS_NUM + 1;
+	u32 gpmc_base_add = OMAP34XX_GPMC_VIRT;
+
+	while (cs < GPMC_CS_NUM) {
+		u32 ret = 0;
+		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
+
+		if ((ret & 0xC00) == 0x800) {
+			/* Found it!! */
+			if (nandcs > GPMC_CS_NUM)
+				nandcs = cs;
+		}
+		cs++;
+	}
+	if (nandcs > GPMC_CS_NUM) {
+		printk(KERN_INFO "NAND: Unable to find configuration "
+				" in GPMC\n ");
+		return;
+	}
+
+	if (nandcs < GPMC_CS_NUM) {
+		board_nand_init(pia35x_nand_partitions,
+				ARRAY_SIZE(pia35x_nand_partitions), nandcs, NAND_BUSWIDTH_16);
+//		am3517crane_nand_data.cs   = nandcs;
+//		am3517crane_nand_data.gpmc_cs_baseaddr =
+//		(void *)(gpmc_base_add + GPMC_CS0_BASE + nandcs*GPMC_CS_SIZE);
+//
+//		am3517crane_nand_data.gpmc_baseaddr = (void *)(gpmc_base_add);
+//
+//		if (platform_device_register(&am3517crane_nand_device) < 0)
+//			printk(KERN_ERR "Unable to register NAND device\n");
+
+	}
+#endif /* 0 - old nand detection */
+	board_nand_init(pia35x_nand_partitions,
+			ARRAY_SIZE(pia35x_nand_partitions),
+			PIA35X_NAND_CS, NAND_BUSWIDTH_16);
+}
+
+/*
+ * I2C
+ */
+static struct i2c_board_info __initdata pia35x_i2c1_info[] = {
+#if defined(CONFIG_REGULATOR_TPS6507X)
+		/* power regulator TPS650732 */
+		{
+				I2C_BOARD_INFO("tps6507x", 0x48),
+				.flags = I2C_CLIENT_WAKE,
+				.irq = INT_34XX_SYS_NIRQ,
+				.platform_data = &pia35x_tps_board,
+		},
+#endif /* CONFIG_REGULATOR_TPS6507X */
+		/* RTC + WDOG */
+		{
+				I2C_BOARD_INFO("ds1374", 0x68),
+		},
+
+};
+
+static struct i2c_board_info __initdata pia35x_i2c2_info[] = {
+		/* temperature sensor LM75 */
+		{
+				I2C_BOARD_INFO("lm75", 0x48),
+		},
+};
+
+static struct i2c_board_info __initdata pia35x_i2c3_info[] = {
+};
+
+static int __init pia35x_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 400, pia35x_i2c1_info, ARRAY_SIZE(pia35x_i2c1_info));
+	omap_register_i2c_bus(2, 400, pia35x_i2c2_info, ARRAY_SIZE(pia35x_i2c2_info));
+	omap_register_i2c_bus(3, 400, pia35x_i2c3_info, ARRAY_SIZE(pia35x_i2c3_info));
+
+	return 0;
+}
+
+static void __init pia35x_init_irq(void)
+{
+	omap_board_config = am3517_crane_config;
+	omap_board_config_size = ARRAY_SIZE(am3517_crane_config);
+
+	omap2_init_common_infrastructure();
+	omap2_init_common_devices(NULL, NULL);
+	omap_init_irq();
+	gpmc_init();
+}
+
+/*
+ * base initialisation function
+ */
+static void __init pia35x_init(void)
+{
+	int ret;
+
+	pr_info("pia35x_init: init pin muc\n");
+	ret = omap3_mux_init(board_mux, OMAP_PACKAGE_CBB);
+	if (ret)
+		pr_warning("pia35x_init: MUX init failed: %d\n", ret);
+
+	pr_info("pia35x_init: init I2C busses\n");
+	pia35x_i2c_init();
+
+	pr_info("pia35x_init: init serial ports\n");
+	omap_serial_init();
+
+	pr_info("pia35x_init: init NAND\n");
+	pia35x_flash_init();
+
+	pr_info("pia35x_init: init USB OTG\n");
+	pia35x_musb_init();
+
+	pr_info("pia35x_init: init ETH\n");
+	pia35x_ethernet_init(&pia35x_emac_pdata);
+	pr_info("pia35x_init: init CAN\n");
+	pia35x_can_init(&pia35x_hecc_pdata);
+
+	pr_info("pia35x_init: init MMC\n");
+	pia35x_mmc_init();
+
+	pr_info("pia35x_init: init WLAN & BT\n");
+	pia35x_wlan_init();
+	pia35x_bt_init();
+
+	pr_info("pia35x_init: init GSM\n");
+	pia35x_gsm_init();
+
+	/* TODO
+	 * WLAN
+	 * bluetooth
+	 * display?
+	 */
+
+#ifdef NOT_USED
+	/* Configure GPIO for EHCI port */
+	if (omap_mux_init_gpio(GPIO_USB_NRESET, OMAP_PIN_OUTPUT)) {
+		pr_err("Can not configure mux for GPIO_USB_NRESET %d\n",
+			GPIO_USB_NRESET);
+		return;
+	}
+
+	if (omap_mux_init_gpio(GPIO_USB_POWER, OMAP_PIN_OUTPUT)) {
+		pr_err("Can not configure mux for GPIO_USB_POWER %d\n",
+			GPIO_USB_POWER);
+		return;
+	}
+
+	ret = gpio_request(GPIO_USB_POWER, "usb_ehci_enable");
+	if (ret < 0) {
+		pr_err("Can not request GPIO %d\n", GPIO_USB_POWER);
+		return;
+	}
+
+	ret = gpio_direction_output(GPIO_USB_POWER, 1);
+	if (ret < 0) {
+		gpio_free(GPIO_USB_POWER);
+		pr_err("Unable to initialize EHCI power\n");
+		return;
+	}
+
+	usb_ehci_init(&ehci_pdata);
+#endif
+
+}
+
+MACHINE_START(PIA_AM35X, "PIA AM35X")
+	.boot_params  = 0x80000100,
+	.map_io       = omap3_map_io,
+	.reserve      = omap_reserve,
+	.init_irq     = pia35x_init_irq,
+	.init_machine = pia35x_init,
+	.timer		  = &omap_timer,
+MACHINE_END
diff --git a/arch/arm/mach-omap2/hsmmc.c b/arch/arm/mach-omap2/hsmmc.c
index d3d4b5c..2b5c0de 100644
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -183,6 +183,7 @@ static void hsmmc23_before_set_reg(struct device *dev, int slot,
 {
 	struct omap_mmc_platform_data *mmc = dev->platform_data;
 
+	pr_warning("pia35x: hsmmc23 po:%d ic:%d\n", power_on, mmc->slots[0].internal_clock);
 	if (mmc->slots[0].remux)
 		mmc->slots[0].remux(dev, slot, power_on);
 
@@ -217,6 +218,7 @@ void __init omap2_hsmmc_init(struct omap2_hsmmc_info *controllers)
 	int i;
 	u32 reg;
 
+	pr_warning("pia35x: %s\n", __func__);
 	if (!cpu_is_omap44xx()) {
 		if (cpu_is_omap2430()) {
 			control_pbias_offset = OMAP243X_CONTROL_PBIAS_LITE;
@@ -243,6 +245,8 @@ void __init omap2_hsmmc_init(struct omap2_hsmmc_info *controllers)
 	for (c = controllers; c->mmc; c++) {
 		struct hsmmc_controller *hc = hsmmc + c->mmc - 1;
 		struct omap_mmc_platform_data *mmc = hsmmc_data[c->mmc - 1];
+		pr_warning("pia35x: %s: init controller: %d", __func__, c->mmc);
+
 
 		if (!c->mmc || c->mmc > nr_hsmmc) {
 			pr_debug("MMC%d: no such controller\n", c->mmc);
@@ -316,6 +320,7 @@ void __init omap2_hsmmc_init(struct omap2_hsmmc_info *controllers)
 						 MMC_VDD_31_32;
 		else
 			mmc->slots[0].ocr_mask = c->ocr_mask;
+		pr_warn("pia35x: %s: ocr_mask: %d", __func__, mmc->slots[0].ocr_mask);
 
 		if (cpu_is_omap3517() || cpu_is_omap3505() || cpu_is_ti81xx())
 			mmc->slots[0].set_power = nop_mmc_set_power;
@@ -326,6 +331,7 @@ void __init omap2_hsmmc_init(struct omap2_hsmmc_info *controllers)
 				cpu_is_ti814x())
 			mmc->slots[0].features |= HSMMC_HAS_UPDATED_RESET;
 
+		pr_warn("pia35x: %s: feat: %d", __func__, mmc->slots[0].features);
 		switch (c->mmc) {
 		case 1:
 			if (mmc->slots[0].features & HSMMC_HAS_PBIAS) {
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 2fea897..4d97e0e 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -12,7 +12,7 @@
 #
 #   http://www.arm.linux.org.uk/developer/machines/?action=new
 #
-# Last update: Sun Dec 12 23:24:27 2010
+# Last update: Tue Aug 9 15:02:23 2011
 #
 # machine_is_xxx	CONFIG_xxxx		MACH_TYPE_xxx		number
 #
@@ -1319,7 +1319,7 @@ mistral			MACH_MISTRAL		MISTRAL			1315
 msm			MACH_MSM		MSM			1316
 ct5910			MACH_CT5910		CT5910			1317
 ct5912			MACH_CT5912		CT5912			1318
-hynet_ine		MACH_HYNET_INE		HYNET_INE		1319
+argonst_mp		MACH_HYNET_INE		HYNET_INE		1319
 hynet_app		MACH_HYNET_APP		HYNET_APP		1320
 msm7200			MACH_MSM7200		MSM7200			1321
 msm7600			MACH_MSM7600		MSM7600			1322
@@ -1777,7 +1777,6 @@ wdg002			MACH_WDG002		WDG002			1785
 sg560adsl		MACH_SG560ADSL		SG560ADSL		1786
 nextio_n2800_ica	MACH_NEXTIO_N2800_ICA	NEXTIO_N2800_ICA	1787
 dove_db			MACH_DOVE_DB		DOVE_DB			1788
-marvell_newdb		MACH_MARVELL_NEWDB	MARVELL_NEWDB		1789
 vandihud		MACH_VANDIHUD		VANDIHUD		1790
 magx_e8			MACH_MAGX_E8		MAGX_E8			1791
 magx_z6			MACH_MAGX_Z6		MAGX_Z6			1792
@@ -1877,7 +1876,6 @@ ued			MACH_UED		UED			1885
 esiblade		MACH_ESIBLADE		ESIBLADE		1886
 eye02			MACH_EYE02		EYE02			1887
 imx27kbd		MACH_IMX27KBD		IMX27KBD		1888
-sst61vc010_fpga		MACH_SST61VC010_FPGA	SST61VC010_FPGA		1889
 kixvp435		MACH_KIXVP435		KIXVP435		1890
 kixnp435		MACH_KIXNP435		KIXNP435		1891
 africa			MACH_AFRICA		AFRICA			1892
@@ -2240,7 +2238,7 @@ arm_ultimator2		MACH_ARM_ULTIMATOR2	ARM_ULTIMATOR2		2250
 vs_v210			MACH_VS_V210		VS_V210			2252
 vs_v212			MACH_VS_V212		VS_V212			2253
 hmt			MACH_HMT		HMT			2254
-suen3			MACH_SUEN3		SUEN3			2255
+km_kirkwood		MACH_KM_KIRKWOOD	KM_KIRKWOOD		2255
 vesper			MACH_VESPER		VESPER			2256
 str9			MACH_STR9		STR9			2257
 omap3_wl_ff		MACH_OMAP3_WL_FF	OMAP3_WL_FF		2258
@@ -2308,7 +2306,6 @@ ecac2378		MACH_ECAC2378		ECAC2378		2319
 tazkiosk		MACH_TAZKIOSK		TAZKIOSK		2320
 whiterabbit_mch		MACH_WHITERABBIT_MCH	WHITERABBIT_MCH		2321
 sbox9263		MACH_SBOX9263		SBOX9263		2322
-oreo			MACH_OREO		OREO			2323
 smdk6442		MACH_SMDK6442		SMDK6442		2324
 openrd_base		MACH_OPENRD_BASE	OPENRD_BASE		2325
 incredible		MACH_INCREDIBLE		INCREDIBLE		2326
@@ -2374,7 +2371,6 @@ sch_m490		MACH_SCH_M490		SCH_M490		2386
 rbl01			MACH_RBL01		RBL01			2387
 omnifi			MACH_OMNIFI		OMNIFI			2388
 otavalo			MACH_OTAVALO		OTAVALO			2389
-sienna			MACH_SIENNA		SIENNA			2390
 htc_excalibur_s620	MACH_HTC_EXCALIBUR_S620	HTC_EXCALIBUR_S620	2391
 htc_opal		MACH_HTC_OPAL		HTC_OPAL		2392
 touchbook		MACH_TOUCHBOOK		TOUCHBOOK		2393
@@ -2446,7 +2442,6 @@ siogentoo1		MACH_SIOGENTOO1		SIOGENTOO1		2458
 siogentoo2		MACH_SIOGENTOO2		SIOGENTOO2		2459
 sm3k			MACH_SM3K		SM3K			2460
 acer_tempo_f900		MACH_ACER_TEMPO_F900	ACER_TEMPO_F900		2461
-sst61vc010_dev		MACH_SST61VC010_DEV	SST61VC010_DEV		2462
 glittertind		MACH_GLITTERTIND	GLITTERTIND		2463
 omap_zoom3		MACH_OMAP_ZOOM3		OMAP_ZOOM3		2464
 omap_3630sdp		MACH_OMAP_3630SDP	OMAP_3630SDP		2465
@@ -2498,7 +2493,6 @@ hiram			MACH_HIRAM		HIRAM			2510
 phy3250			MACH_PHY3250		PHY3250			2511
 ea3250			MACH_EA3250		EA3250			2512
 fdi3250			MACH_FDI3250		FDI3250			2513
-whitestone		MACH_WHITESTONE		WHITESTONE		2514
 at91sam9263nit		MACH_AT91SAM9263NIT	AT91SAM9263NIT		2515
 ccmx51			MACH_CCMX51		CCMX51			2516
 ccmx51js		MACH_CCMX51JS		CCMX51JS		2517
@@ -2561,7 +2555,7 @@ magnolia2		MACH_MAGNOLIA2		MAGNOLIA2		2573
 emxx			MACH_EMXX		EMXX			2574
 outlaw			MACH_OUTLAW		OUTLAW			2575
 riot_bei2		MACH_RIOT_BEI2		RIOT_BEI2		2576
-riot_vox		MACH_RIOT_VOX		RIOT_VOX		2577
+riot_gx2		MACH_RIOT_VOX		RIOT_VOX		2577
 riot_x37		MACH_RIOT_X37		RIOT_X37		2578
 mega25mx		MACH_MEGA25MX		MEGA25MX		2579
 benzina2		MACH_BENZINA2		BENZINA2		2580
@@ -2575,14 +2569,13 @@ p3600			MACH_P3600		P3600			2587
 dlt2			MACH_DLT2		DLT2			2588
 df3120			MACH_DF3120		DF3120			2589
 ecucore_9g20		MACH_ECUCORE_9G20	ECUCORE_9G20		2590
-nautel_lpc3240		MACH_NAUTEL_LPC3240	NAUTEL_LPC3240		2591
+nautel_am35xx		MACH_NAUTEL_LPC3240	NAUTEL_LPC3240		2591
 glacier			MACH_GLACIER		GLACIER			2592
 phrazer_bulldog		MACH_PHRAZER_BULLDOG	PHRAZER_BULLDOG		2593
 omap3_bulldog		MACH_OMAP3_BULLDOG	OMAP3_BULLDOG		2594
 pca101			MACH_PCA101		PCA101			2595
 buzzc			MACH_BUZZC		BUZZC			2596
 sasie2			MACH_SASIE2		SASIE2			2597
-davinci_cio		MACH_DAVINCI_CIO	DAVINCI_CIO		2598
 smartmeter_dl		MACH_SMARTMETER_DL	SMARTMETER_DL		2599
 wzl6410			MACH_WZL6410		WZL6410			2600
 wzl6410m		MACH_WZL6410M		WZL6410M		2601
@@ -2591,7 +2584,6 @@ wzl6410i		MACH_WZL6410I		WZL6410I		2603
 spacecom1		MACH_SPACECOM1		SPACECOM1		2604
 pingu920		MACH_PINGU920		PINGU920		2605
 bravoc			MACH_BRAVOC		BRAVOC			2606
-cybo2440		MACH_CYBO2440		CYBO2440		2607
 vdssw			MACH_VDSSW		VDSSW			2608
 romulus			MACH_ROMULUS		ROMULUS			2609
 omap_magic		MACH_OMAP_MAGIC		OMAP_MAGIC		2610
@@ -2667,7 +2659,7 @@ msm7x30_surf		MACH_MSM7X30_SURF	MSM7X30_SURF		2679
 micro2440		MACH_MICRO2440		MICRO2440		2680
 am2440			MACH_AM2440		AM2440			2681
 tq2440			MACH_TQ2440		TQ2440			2682
-lpc2478oem		MACH_LPC2478OEM		LPC2478OEM		2683
+ea2478devkit		MACH_EA2478DEVKIT	EA2478DEVKIT		2683
 ak880x			MACH_AK880X		AK880X			2684
 cobra3530		MACH_COBRA3530		COBRA3530		2685
 pmppb			MACH_PMPPB		PMPPB			2686
@@ -2683,7 +2675,6 @@ lkevm			MACH_LKEVM		LKEVM			2695
 mw6410			MACH_MW6410		MW6410			2696
 terastation_wxl		MACH_TERASTATION_WXL	TERASTATION_WXL		2697
 cpu8000e		MACH_CPU8000E		CPU8000E		2698
-catania			MACH_CATANIA		CATANIA			2699
 tokyo			MACH_TOKYO		TOKYO			2700
 msm7201a_surf		MACH_MSM7201A_SURF	MSM7201A_SURF		2701
 msm7201a_ffa		MACH_MSM7201A_FFA	MSM7201A_FFA		2702
@@ -2735,13 +2726,12 @@ vpnext_mpu		MACH_VPNEXT_MPU		VPNEXT_MPU		2747
 bcmring_tablet_v1	MACH_BCMRING_TABLET_V1	BCMRING_TABLET_V1	2748
 sgarm10			MACH_SGARM10		SGARM10			2749
 cm_t3517		MACH_CM_T3517		CM_T3517		2750
-omap3_cps		MACH_OMAP3_CPS		OMAP3_CPS		2751
+dig297			MACH_OMAP3_CPS		OMAP3_CPS		2751
 axar1500_receiver	MACH_AXAR1500_RECEIVER	AXAR1500_RECEIVER	2752
 wbd222			MACH_WBD222		WBD222			2753
 mt65xx			MACH_MT65XX		MT65XX			2754
 msm8x60_surf		MACH_MSM8X60_SURF	MSM8X60_SURF		2755
 msm8x60_sim		MACH_MSM8X60_SIM	MSM8X60_SIM		2756
-vmc300			MACH_VMC300		VMC300			2757
 tcc8000_sdk		MACH_TCC8000_SDK	TCC8000_SDK		2758
 nanos			MACH_NANOS		NANOS			2759
 stamp9g10		MACH_STAMP9G10		STAMP9G10		2760
@@ -2750,7 +2740,6 @@ h6053			MACH_H6053		H6053			2762
 smint01			MACH_SMINT01		SMINT01			2763
 prtlvt2			MACH_PRTLVT2		PRTLVT2			2764
 ap420			MACH_AP420		AP420			2765
-htcshift		MACH_HTCSHIFT		HTCSHIFT		2766
 davinci_dm365_fc	MACH_DAVINCI_DM365_FC	DAVINCI_DM365_FC	2767
 msm8x55_surf		MACH_MSM8X55_SURF	MSM8X55_SURF		2768
 msm8x55_ffa		MACH_MSM8X55_FFA	MSM8X55_FFA		2769
@@ -2761,7 +2750,7 @@ oreo_controller		MACH_OREO_CONTROLLER	OREO_CONTROLLER		2773
 kopin_models		MACH_KOPIN_MODELS	KOPIN_MODELS		2774
 ttc_vision2		MACH_TTC_VISION2	TTC_VISION2		2775
 cns3420vb		MACH_CNS3420VB		CNS3420VB		2776
-lpc2			MACH_LPC2		LPC2			2777
+lpc_evo			MACH_LPC2		LPC2			2777
 olympus			MACH_OLYMPUS		OLYMPUS			2778
 vortex			MACH_VORTEX		VORTEX			2779
 s5pc200			MACH_S5PC200		S5PC200			2780
@@ -2788,7 +2777,6 @@ ti8168evm		MACH_TI8168EVM		TI8168EVM		2800
 neocoreomap		MACH_NEOCOREOMAP	NEOCOREOMAP		2801
 withings_wbp		MACH_WITHINGS_WBP	WITHINGS_WBP		2802
 dbps			MACH_DBPS		DBPS			2803
-sbc9261			MACH_SBC9261		SBC9261			2804
 pcbfp0001		MACH_PCBFP0001		PCBFP0001		2805
 speedy			MACH_SPEEDY		SPEEDY			2806
 chrysaor		MACH_CHRYSAOR		CHRYSAOR		2807
@@ -2812,7 +2800,6 @@ p565			MACH_P565		P565			2824
 acer_a4			MACH_ACER_A4		ACER_A4			2825
 davinci_dm368_bip	MACH_DAVINCI_DM368_BIP	DAVINCI_DM368_BIP	2826
 eshare			MACH_ESHARE		ESHARE			2827
-hw_omapl138_europa	MACH_HW_OMAPL138_EUROPA	HW_OMAPL138_EUROPA	2828
 wlbargn			MACH_WLBARGN		WLBARGN			2829
 bm170			MACH_BM170		BM170			2830
 netspace_mini_v2	MACH_NETSPACE_MINI_V2	NETSPACE_MINI_V2	2831
@@ -2879,7 +2866,6 @@ davinci_picto		MACH_DAVINCI_PICTO	DAVINCI_PICTO		2891
 mecha			MACH_MECHA		MECHA			2892
 bubba3			MACH_BUBBA3		BUBBA3			2893
 pupitre			MACH_PUPITRE		PUPITRE			2894
-tegra_harmony		MACH_TEGRA_HARMONY	TEGRA_HARMONY		2895
 tegra_vogue		MACH_TEGRA_VOGUE	TEGRA_VOGUE		2896
 tegra_e1165		MACH_TEGRA_E1165	TEGRA_E1165		2897
 simplenet		MACH_SIMPLENET		SIMPLENET		2898
@@ -2969,7 +2955,6 @@ netspace_lite_v2	MACH_NETSPACE_LITE_V2	NETSPACE_LITE_V2	2983
 ssc			MACH_SSC		SSC			2984
 premierwave_en		MACH_PREMIERWAVE_EN	PREMIERWAVE_EN		2985
 wasabi			MACH_WASABI		WASABI			2986
-vivow			MACH_VIVOW		VIVOW			2987
 mx50_rdp		MACH_MX50_RDP		MX50_RDP		2988
 universal_c210		MACH_UNIVERSAL_C210	UNIVERSAL_C210		2989
 real6410		MACH_REAL6410		REAL6410		2990
@@ -2987,7 +2972,7 @@ pxwnas_500_1000		MACH_PXWNAS_500_1000	PXWNAS_500_1000		3001
 ea20			MACH_EA20		EA20			3002
 awm2			MACH_AWM2		AWM2			3003
 ti8148evm		MACH_TI8148EVM		TI8148EVM		3004
-tegra_seaboard		MACH_TEGRA_SEABOARD	TEGRA_SEABOARD		3005
+seaboard		MACH_SEABOARD		SEABOARD		3005
 linkstation_chlv2	MACH_LINKSTATION_CHLV2	LINKSTATION_CHLV2	3006
 tera_pro2_rack		MACH_TERA_PRO2_RACK	TERA_PRO2_RACK		3007
 rubys			MACH_RUBYS		RUBYS			3008
@@ -3017,12 +3002,10 @@ remus			MACH_REMUS		REMUS			3031
 at91cap7xdk		MACH_AT91CAP7XDK	AT91CAP7XDK		3032
 at91cap7stk		MACH_AT91CAP7STK	AT91CAP7STK		3033
 kt_sbc_sam9_1		MACH_KT_SBC_SAM9_1	KT_SBC_SAM9_1		3034
-oratisrouter		MACH_ORATISROUTER	ORATISROUTER		3035
 armada_xp_db		MACH_ARMADA_XP_DB	ARMADA_XP_DB		3036
 spdm			MACH_SPDM		SPDM			3037
 gtib			MACH_GTIB		GTIB			3038
 dgm3240			MACH_DGM3240		DGM3240			3039
-atlas_i_lpe		MACH_ATLAS_I_LPE	ATLAS_I_LPE		3040
 htcmega			MACH_HTCMEGA		HTCMEGA			3041
 tricorder		MACH_TRICORDER		TRICORDER		3042
 tx28			MACH_TX28		TX28			3043
@@ -3038,6 +3021,7 @@ s5pc110_crespo		MACH_S5PC110_CRESPO	S5PC110_CRESPO		3052
 controltek9g20		MACH_CONTROLTEK9G20	CONTROLTEK9G20		3053
 tin307			MACH_TIN307		TIN307			3054
 tin510			MACH_TIN510		TIN510			3055
+ep3505			MACH_EP3517		EP3517			3056
 bluecheese		MACH_BLUECHEESE		BLUECHEESE		3057
 tem3x30			MACH_TEM3X30		TEM3X30			3058
 harvest_desoto		MACH_HARVEST_DESOTO	HARVEST_DESOTO		3059
@@ -3062,7 +3046,6 @@ clod			MACH_CLOD		CLOD			3077
 rump			MACH_RUMP		RUMP			3078
 tenderloin		MACH_TENDERLOIN		TENDERLOIN		3079
 shortloin		MACH_SHORTLOIN		SHORTLOIN		3080
-crespo			MACH_CRESPO		CRESPO			3081
 antares			MACH_ANTARES		ANTARES			3082
 wb40n			MACH_WB40N		WB40N			3083
 herring			MACH_HERRING		HERRING			3084
@@ -3111,7 +3094,6 @@ smartqv3		MACH_SMARTQV3		SMARTQV3		3126
 smartqv7		MACH_SMARTQV7		SMARTQV7		3127
 paz00			MACH_PAZ00		PAZ00			3128
 acmenetusfoxg20		MACH_ACMENETUSFOXG20	ACMENETUSFOXG20		3129
-htcwillow		MACH_HTCWILLOW		HTCWILLOW		3130
 fwbd_0404		MACH_FWBD_0404		FWBD_0404		3131
 hdgu			MACH_HDGU		HDGU			3132
 pyramid			MACH_PYRAMID		PYRAMID			3133
@@ -3162,7 +3144,6 @@ b5500			MACH_B5500		B5500			3177
 s5500			MACH_S5500		S5500			3178
 icon			MACH_ICON		ICON			3179
 elephant		MACH_ELEPHANT		ELEPHANT		3180
-msm8x60_fusion		MACH_MSM8X60_FUSION	MSM8X60_FUSION		3181
 shooter			MACH_SHOOTER		SHOOTER			3182
 spade_lte		MACH_SPADE_LTE		SPADE_LTE		3183
 philhwani		MACH_PHILHWANI		PHILHWANI		3184
@@ -3174,13 +3155,11 @@ ag5evm			MACH_AG5EVM		AG5EVM			3189
 sc575plc		MACH_SC575PLC		SC575PLC		3190
 sc575hmi		MACH_SC575IPC		SC575IPC		3191
 omap3_tdm3730		MACH_OMAP3_TDM3730	OMAP3_TDM3730		3192
-g7			MACH_G7			G7			3193
 top9000_eval		MACH_TOP9000_EVAL	TOP9000_EVAL		3194
 top9000_su		MACH_TOP9000_SU		TOP9000_SU		3195
 utm300			MACH_UTM300		UTM300			3196
 tsunagi			MACH_TSUNAGI		TSUNAGI			3197
 ts75xx			MACH_TS75XX		TS75XX			3198
-msm8x60_fusn_ffa	MACH_MSM8X60_FUSN_FFA	MSM8X60_FUSN_FFA	3199
 ts47xx			MACH_TS47XX		TS47XX			3200
 da850_k5		MACH_DA850_K5		DA850_K5		3201
 ax502			MACH_AX502		AX502			3202
@@ -3190,7 +3169,7 @@ synergy			MACH_SYNERGY		SYNERGY			3205
 ics_if_voip		MACH_ICS_IF_VOIP	ICS_IF_VOIP		3206
 wlf_cragg_6410		MACH_WLF_CRAGG_6410	WLF_CRAGG_6410		3207
 punica			MACH_PUNICA		PUNICA			3208
-sbc_nt250		MACH_SBC_NT250		SBC_NT250		3209
+trimslice		MACH_TRIMSLICE		TRIMSLICE		3209
 mx27_wmultra		MACH_MX27_WMULTRA	MX27_WMULTRA		3210
 mackerel		MACH_MACKEREL		MACKEREL		3211
 fa9x27			MACH_FA9X27		FA9X27			3213
@@ -3219,3 +3198,432 @@ pivicc			MACH_PIVICC		PIVICC			3235
 pcm048			MACH_PCM048		PCM048			3236
 dds			MACH_DDS		DDS			3237
 chalten_xa1		MACH_CHALTEN_XA1	CHALTEN_XA1		3238
+ts48xx			MACH_TS48XX		TS48XX			3239
+tonga2_tfttimer		MACH_TONGA2_TFTTIMER	TONGA2_TFTTIMER		3240
+whistler		MACH_WHISTLER		WHISTLER		3241
+asl_phoenix		MACH_ASL_PHOENIX	ASL_PHOENIX		3242
+at91sam9263otlite	MACH_AT91SAM9263OTLITE	AT91SAM9263OTLITE	3243
+ddplug			MACH_DDPLUG		DDPLUG			3244
+d2plug			MACH_D2PLUG		D2PLUG			3245
+kzm9d			MACH_KZM9D		KZM9D			3246
+verdi_lte		MACH_VERDI_LTE		VERDI_LTE		3247
+nanozoom		MACH_NANOZOOM		NANOZOOM		3248
+dm3730_som_lv		MACH_DM3730_SOM_LV	DM3730_SOM_LV		3249
+dm3730_torpedo		MACH_DM3730_TORPEDO	DM3730_TORPEDO		3250
+anchovy			MACH_ANCHOVY		ANCHOVY			3251
+re2rev20		MACH_RE2REV20		RE2REV20		3253
+re2rev21		MACH_RE2REV21		RE2REV21		3254
+cns21xx			MACH_CNS21XX		CNS21XX			3255
+rider			MACH_RIDER		RIDER			3257
+nsk330			MACH_NSK330		NSK330			3258
+cns2133evb		MACH_CNS2133EVB		CNS2133EVB		3259
+z3_816x_mod		MACH_Z3_816X_MOD	Z3_816X_MOD		3260
+z3_814x_mod		MACH_Z3_814X_MOD	Z3_814X_MOD		3261
+beect			MACH_BEECT		BEECT			3262
+dma_thunderbug		MACH_DMA_THUNDERBUG	DMA_THUNDERBUG		3263
+omn_at91sam9g20		MACH_OMN_AT91SAM9G20	OMN_AT91SAM9G20		3264
+mx25_e2s_uc		MACH_MX25_E2S_UC	MX25_E2S_UC		3265
+mione			MACH_MIONE		MIONE			3266
+top9000_tcu		MACH_TOP9000_TCU	TOP9000_TCU		3267
+top9000_bsl		MACH_TOP9000_BSL	TOP9000_BSL		3268
+kingdom			MACH_KINGDOM		KINGDOM			3269
+armadillo460		MACH_ARMADILLO460	ARMADILLO460		3270
+lq2			MACH_LQ2		LQ2			3271
+sweda_tms2		MACH_SWEDA_TMS2		SWEDA_TMS2		3272
+mx53_loco		MACH_MX53_LOCO		MX53_LOCO		3273
+acer_a8			MACH_ACER_A8		ACER_A8			3275
+acer_gauguin		MACH_ACER_GAUGUIN	ACER_GAUGUIN		3276
+guppy			MACH_GUPPY		GUPPY			3277
+mx61_ard		MACH_MX61_ARD		MX61_ARD		3278
+tx53			MACH_TX53		TX53			3279
+omapl138_case_a3	MACH_OMAPL138_CASE_A3	OMAPL138_CASE_A3	3280
+uemd			MACH_UEMD		UEMD			3281
+ccwmx51mut		MACH_CCWMX51MUT		CCWMX51MUT		3282
+rockhopper		MACH_ROCKHOPPER		ROCKHOPPER		3283
+encore			MACH_ENCORE		ENCORE			3284
+hkdkc100		MACH_HKDKC100		HKDKC100		3285
+ts42xx			MACH_TS42XX		TS42XX			3286
+aebl			MACH_AEBL		AEBL			3287
+wario			MACH_WARIO		WARIO			3288
+gfs_spm			MACH_GFS_SPM		GFS_SPM			3289
+cm_t3730		MACH_CM_T3730		CM_T3730		3290
+isc3			MACH_ISC3		ISC3			3291
+rascal			MACH_RASCAL		RASCAL			3292
+hrefv60			MACH_HREFV60		HREFV60			3293
+tpt_2_0			MACH_TPT_2_0		TPT_2_0			3294
+pydtd			MACH_PYRAMID_TD		PYRAMID_TD		3295
+splendor		MACH_SPLENDOR		SPLENDOR		3296
+guf_vincell		MACH_GUF_PLANET		GUF_PLANET		3297
+msm8x60_qt		MACH_MSM8X60_QT		MSM8X60_QT		3298
+htc_hd_mini		MACH_HTC_HD_MINI	HTC_HD_MINI		3299
+athene			MACH_ATHENE		ATHENE			3300
+deep_r_ek_1		MACH_DEEP_R_EK_1	DEEP_R_EK_1		3301
+vivow_ct		MACH_VIVOW_CT		VIVOW_CT		3302
+nery_1000		MACH_NERY_1000		NERY_1000		3303
+rfl109145_ssrv		MACH_RFL109145_SSRV	RFL109145_SSRV		3304
+nmh			MACH_NMH		NMH			3305
+wn802t			MACH_WN802T		WN802T			3306
+dragonet		MACH_DRAGONET		DRAGONET		3307
+geneva_b4		MACH_GENEVA_B		GENEVA_B		3308
+at91sam9263desk16l	MACH_AT91SAM9263DESK16L	AT91SAM9263DESK16L	3309
+bcmhana_sv		MACH_BCMHANA_SV		BCMHANA_SV		3310
+bcmhana_tablet		MACH_BCMHANA_TABLET	BCMHANA_TABLET		3311
+koi			MACH_KOI		KOI			3312
+ts4800			MACH_TS4800		TS4800			3313
+tqma9263		MACH_TQMA9263		TQMA9263		3314
+holiday			MACH_HOLIDAY		HOLIDAY			3315
+dma_6410		MACH_DMA6410		DMA6410			3316
+pcats_overlay		MACH_PCATS_OVERLAY	PCATS_OVERLAY		3317
+hwgw6410		MACH_HWGW6410		HWGW6410		3318
+shenzhou		MACH_SHENZHOU		SHENZHOU		3319
+cwme9210		MACH_CWME9210		CWME9210		3320
+cwme9210js		MACH_CWME9210JS		CWME9210JS		3321
+pgs_v1			MACH_PGS_SITARA		PGS_SITARA		3322
+colibri_tegra2		MACH_COLIBRI_TEGRA2	COLIBRI_TEGRA2		3323
+w21			MACH_W21		W21			3324
+polysat1		MACH_POLYSAT1		POLYSAT1		3325
+dataway			MACH_DATAWAY		DATAWAY			3326
+cobral138		MACH_COBRAL138		COBRAL138		3327
+roverpcs8		MACH_ROVERPCS8		ROVERPCS8		3328
+marvelc			MACH_MARVELC		MARVELC			3329
+navefihid		MACH_NAVEFIHID		NAVEFIHID		3330
+dm365_cv100		MACH_DM365_CV100	DM365_CV100		3331
+able			MACH_ABLE		ABLE			3332
+legacy			MACH_LEGACY		LEGACY			3333
+icong			MACH_ICONG		ICONG			3334
+rover_g8		MACH_ROVER_G8		ROVER_G8		3335
+t5388p			MACH_T5388P		T5388P			3336
+dingo			MACH_DINGO		DINGO			3337
+goflexhome		MACH_GOFLEXHOME		GOFLEXHOME		3338
+lanreadyfn511		MACH_LANREADYFN511	LANREADYFN511		3340
+omap3_baia		MACH_OMAP3_BAIA		OMAP3_BAIA		3341
+omap3smartdisplay	MACH_OMAP3SMARTDISPLAY	OMAP3SMARTDISPLAY	3342
+xilinx			MACH_XILINX		XILINX			3343
+a2f			MACH_A2F		A2F			3344
+sky25			MACH_SKY25		SKY25			3345
+ccmx53			MACH_CCMX53		CCMX53			3346
+ccmx53js		MACH_CCMX53JS		CCMX53JS		3347
+ccwmx53			MACH_CCWMX53		CCWMX53			3348
+ccwmx53js		MACH_CCWMX53JS		CCWMX53JS		3349
+frisms			MACH_FRISMS		FRISMS			3350
+msm7x27a_ffa		MACH_MSM7X27A_FFA	MSM7X27A_FFA		3351
+msm7x27a_surf		MACH_MSM7X27A_SURF	MSM7X27A_SURF		3352
+msm7x27a_rumi3		MACH_MSM7X27A_RUMI3	MSM7X27A_RUMI3		3353
+dimmsam9g20		MACH_DIMMSAM9G20	DIMMSAM9G20		3354
+dimm_imx28		MACH_DIMM_IMX28		DIMM_IMX28		3355
+amk_a4			MACH_AMK_A4		AMK_A4			3356
+gnet_sgme		MACH_GNET_SGME		GNET_SGME		3357
+shooter_u		MACH_SHOOTER_U		SHOOTER_U		3358
+vmx53			MACH_VMX53		VMX53			3359
+rhino			MACH_RHINO		RHINO			3360
+armlex4210		MACH_ARMLEX4210		ARMLEX4210		3361
+swarcoextmodem		MACH_SWARCOEXTMODEM	SWARCOEXTMODEM		3362
+snowball		MACH_SNOWBALL		SNOWBALL		3363
+pcm049			MACH_PCM049		PCM049			3364
+vigor			MACH_VIGOR		VIGOR			3365
+oslo_amundsen		MACH_OSLO_AMUNDSEN	OSLO_AMUNDSEN		3366
+gsl_diamond		MACH_GSL_DIAMOND	GSL_DIAMOND		3367
+cv2201			MACH_CV2201		CV2201			3368
+cv2202			MACH_CV2202		CV2202			3369
+cv2203			MACH_CV2203		CV2203			3370
+vit_ibox		MACH_VIT_IBOX		VIT_IBOX		3371
+dm6441_esp		MACH_DM6441_ESP		DM6441_ESP		3372
+at91sam9x5ek		MACH_AT91SAM9X5EK	AT91SAM9X5EK		3373
+libra			MACH_LIBRA		LIBRA			3374
+easycrrh		MACH_EASYCRRH		EASYCRRH		3375
+tripel			MACH_TRIPEL		TRIPEL			3376
+endian_mini		MACH_ENDIAN_MINI	ENDIAN_MINI		3377
+xilinx_ep107		MACH_XILINX_EP107	XILINX_EP107		3378
+nuri			MACH_NURI		NURI			3379
+janus			MACH_JANUS		JANUS			3380
+ddnas			MACH_DDNAS		DDNAS			3381
+tag			MACH_TAG		TAG			3382
+tagw			MACH_TAGW		TAGW			3383
+nitrogen_vm_imx51	MACH_NITROGEN_VM_IMX51	NITROGEN_VM_IMX51	3384
+viprinet		MACH_VIPRINET		VIPRINET		3385
+bockw			MACH_BOCKW		BOCKW			3386
+eva2000			MACH_EVA2000		EVA2000			3387
+steelyard		MACH_STEELYARD		STEELYARD		3388
+ea2468devkit		MACH_LPC2468OEM		LPC2468OEM		3389
+sdh001			MACH_MACH_SDH001	MACH_SDH001		3390
+fe2478mblox		MACH_LPC2478MICROBLOX	LPC2478MICROBLOX	3391
+nsslsboard		MACH_NSSLSBOARD		NSSLSBOARD		3392
+geneva_b5		MACH_GENEVA_B5		GENEVA_B5		3393
+spear1340		MACH_SPEAR1340		SPEAR1340		3394
+rexmas			MACH_REXMAS		REXMAS			3395
+msm8960_cdp		MACH_MSM8960_CDP	MSM8960_CDP		3396
+msm8960_mtp		MACH_MSM8960_MDP	MSM8960_MDP		3397
+msm8960_fluid		MACH_MSM8960_FLUID	MSM8960_FLUID		3398
+msm8960_apq		MACH_MSM8960_APQ	MSM8960_APQ		3399
+helios_v2		MACH_HELIOS_V2		HELIOS_V2		3400
+mif10p			MACH_MIF10P		MIF10P			3401
+iam28			MACH_IAM28		IAM28			3402
+picasso			MACH_PICASSO		PICASSO			3403
+mr301a			MACH_MR301A		MR301A			3404
+notle			MACH_NOTLE		NOTLE			3405
+eelx2			MACH_EELX2		EELX2			3406
+moon			MACH_MOON		MOON			3407
+ruby			MACH_RUBY		RUBY			3408
+goldengate		MACH_GOLDENGATE		GOLDENGATE		3409
+ctbu_gen2		MACH_CTBU_GEN2		CTBU_GEN2		3410
+kmp_am17_01		MACH_KMP_AM17_01	KMP_AM17_01		3411
+wtplug			MACH_WTPLUG		WTPLUG			3412
+mx27su2			MACH_MX27SU2		MX27SU2			3413
+nb31			MACH_NB31		NB31			3414
+hjsdu			MACH_HJSDU		HJSDU			3415
+td3_rev1		MACH_TD3_REV1		TD3_REV1		3416
+eag_ci4000		MACH_EAG_CI4000		EAG_CI4000		3417
+net5big_nand_v2		MACH_NET5BIG_NAND_V2	NET5BIG_NAND_V2		3418
+cpx2			MACH_CPX2		CPX2			3419
+net2big_nand_v2		MACH_NET2BIG_NAND_V2	NET2BIG_NAND_V2		3420
+ecuv5			MACH_ECUV5		ECUV5			3421
+hsgx6d			MACH_HSGX6D		HSGX6D			3422
+dawad7			MACH_DAWAD7		DAWAD7			3423
+sam9repeater		MACH_SAM9REPEATER	SAM9REPEATER		3424
+gt_i5700		MACH_GT_I5700		GT_I5700		3425
+ctera_plug_c2		MACH_CTERA_PLUG_C2	CTERA_PLUG_C2		3426
+marvelct		MACH_MARVELCT		MARVELCT		3427
+ag11005			MACH_AG11005		AG11005			3428
+omap_tabletblaze	MACH_OMAP_BLAZE		OMAP_BLAZE		3429
+vangogh			MACH_VANGOGH		VANGOGH			3430
+matrix505		MACH_MATRIX505		MATRIX505		3431
+oce_nigma		MACH_OCE_NIGMA		OCE_NIGMA		3432
+t55			MACH_T55		T55			3433
+bio3k			MACH_BIO3K		BIO3K			3434
+expressct		MACH_EXPRESSCT		EXPRESSCT		3435
+cardhu			MACH_CARDHU		CARDHU			3436
+aruba			MACH_ARUBA		ARUBA			3437
+bonaire			MACH_BONAIRE		BONAIRE			3438
+nuc700evb		MACH_NUC700EVB		NUC700EVB		3439
+nuc710evb		MACH_NUC710EVB		NUC710EVB		3440
+nuc740evb		MACH_NUC740EVB		NUC740EVB		3441
+nuc745evb		MACH_NUC745EVB		NUC745EVB		3442
+transcede		MACH_TRANSCEDE		TRANSCEDE		3443
+mora			MACH_MORA		MORA			3444
+nda_evm			MACH_NDA_EVM		NDA_EVM			3445
+timu			MACH_TIMU		TIMU			3446
+expressh		MACH_EXPRESSH		EXPRESSH		3447
+veridis_a300		MACH_VERIDIS_A300	VERIDIS_A300		3448
+dm368_leopard		MACH_DM368_LEOPARD	DM368_LEOPARD		3449
+omap_mcop		MACH_OMAP_MCOP		OMAP_MCOP		3450
+tritip			MACH_TRITIP		TRITIP			3451
+sm1k			MACH_SM1K		SM1K			3452
+monch			MACH_MONCH		MONCH			3453
+curacao			MACH_CURACAO		CURACAO			3454
+origen			MACH_ORIGEN		ORIGEN			3455
+epc10			MACH_EPC10		EPC10			3456
+sgh_i740		MACH_SGH_I740		SGH_I740		3457
+tuna			MACH_TUNA		TUNA			3458
+mx51_tulip		MACH_MX51_TULIP		MX51_TULIP		3459
+mx51_aster7		MACH_MX51_ASTER7	MX51_ASTER7		3460
+acro37xbrd		MACH_ACRO37XBRD		ACRO37XBRD		3461
+elke			MACH_ELKE		ELKE			3462
+sbc6000x		MACH_SBC6000X		SBC6000X		3463
+r1801e			MACH_R1801E		R1801E			3464
+h1600			MACH_H1600		H1600			3465
+mini210			MACH_MINI210		MINI210			3466
+mini8168		MACH_MINI8168		MINI8168		3467
+pc7308			MACH_PC7308		PC7308			3468
+ge863pro3		MACH_GE863		GE863			3469
+kmm2m01			MACH_KMM2M01		KMM2M01			3470
+mx51erebus		MACH_MX51EREBUS		MX51EREBUS		3471
+wm8650refboard		MACH_WM8650REFBOARD	WM8650REFBOARD		3472
+tuxrail			MACH_TUXRAIL		TUXRAIL			3473
+arthur			MACH_ARTHUR		ARTHUR			3474
+doorboy			MACH_DOORBOY		DOORBOY			3475
+xarina			MACH_XARINA		XARINA			3476
+roverx7			MACH_ROVERX7		ROVERX7			3477
+sdvr			MACH_SDVR		SDVR			3478
+acer_maya		MACH_ACER_MAYA		ACER_MAYA		3479
+pico			MACH_PICO		PICO			3480
+cwmx233			MACH_CWMX233		CWMX233			3481
+cwam1808		MACH_CWAM1808		CWAM1808		3482
+cwdm365			MACH_CWDM365		CWDM365			3483
+mx51_moray		MACH_MX51_MORAY		MX51_MORAY		3484
+thales_cbc		MACH_THALES_CBC		THALES_CBC		3485
+bluepoint		MACH_BLUEPOINT		BLUEPOINT		3486
+dir665			MACH_DIR665		DIR665			3487
+acmerover1		MACH_ACMEROVER1		ACMEROVER1		3488
+shooter_ct		MACH_SHOOTER_CT		SHOOTER_CT		3489
+bliss			MACH_BLISS		BLISS			3490
+blissc			MACH_BLISSC		BLISSC			3491
+thales_adc		MACH_THALES_ADC		THALES_ADC		3492
+ubisys_p9d_evp		MACH_UBISYS_P9D_EVP	UBISYS_P9D_EVP		3493
+atdgp318		MACH_ATDGP318		ATDGP318		3494
+dma210u			MACH_DMA210U		DMA210U			3495
+em_t3			MACH_EM_T3		EM_T3			3496
+htx3250			MACH_HTX3250		HTX3250			3497
+g50			MACH_G50		G50			3498
+eco5			MACH_ECO5		ECO5			3499
+wintergrasp		MACH_WINTERGRASP	WINTERGRASP		3500
+puro			MACH_PURO		PURO			3501
+shooter_k		MACH_SHOOTER_K		SHOOTER_K		3502
+nspire			MACH_NSPIRE		NSPIRE			3503
+mickxx			MACH_MICKXX		MICKXX			3504
+lxmb			MACH_LXMB		LXMB			3505
+tmdxscbp6618x		MACH_TMDXSCBP6616X	TMDXSCBP6616X		3506
+adam			MACH_ADAM		ADAM			3507
+b1004			MACH_B1004		B1004			3508
+oboea			MACH_OBOEA		OBOEA			3509
+a1015			MACH_A1015		A1015			3510
+robin_vbdt30		MACH_ROBIN_VBDT30	ROBIN_VBDT30		3511
+tegra_enterprise	MACH_TEGRA_ENTERPRISE	TEGRA_ENTERPRISE	3512
+rfl108200_mk10		MACH_RFL108200_MK10	RFL108200_MK10		3513
+rfl108300_mk16		MACH_RFL108300_MK16	RFL108300_MK16		3514
+rover_v7		MACH_ROVER_V7		ROVER_V7		3515
+miphone			MACH_MIPHONE		MIPHONE			3516
+femtobts		MACH_FEMTOBTS		FEMTOBTS		3517
+monopoli		MACH_MONOPOLI		MONOPOLI		3518
+boss			MACH_BOSS		BOSS			3519
+davinci_dm368_vtam	MACH_DAVINCI_DM368_VTAM	DAVINCI_DM368_VTAM	3520
+clcon			MACH_CLCON		CLCON			3521
+nokia_rm696		MACH_NOKIA_RM696	NOKIA_RM696		3522
+tahiti			MACH_TAHITI		TAHITI			3523
+fighter			MACH_FIGHTER		FIGHTER			3524
+sgh_i710		MACH_SGH_I710		SGH_I710		3525
+integreproscb		MACH_INTEGREPROSCB	INTEGREPROSCB		3526
+monza			MACH_MONZA		MONZA			3527
+calimain		MACH_CALIMAIN		CALIMAIN		3528
+mx6q_sabreauto		MACH_MX6Q_SABREAUTO	MX6Q_SABREAUTO		3529
+gma01x			MACH_GMA01X		GMA01X			3530
+sbc51			MACH_SBC51		SBC51			3531
+fit			MACH_FIT		FIT			3532
+steelhead		MACH_STEELHEAD		STEELHEAD		3533
+panther			MACH_PANTHER		PANTHER			3534
+msm8960_liquid		MACH_MSM8960_LIQUID	MSM8960_LIQUID		3535
+lexikonct		MACH_LEXIKONCT		LEXIKONCT		3536
+ns2816_stb		MACH_NS2816_STB		NS2816_STB		3537
+sei_mm2_lpc3250		MACH_SEI_MM2_LPC3250	SEI_MM2_LPC3250		3538
+cmimx53			MACH_CMIMX53		CMIMX53			3539
+sandwich		MACH_SANDWICH		SANDWICH		3540
+chief			MACH_CHIEF		CHIEF			3541
+pogo_e02		MACH_POGO_E02		POGO_E02		3542
+mikrap_x168		MACH_MIKRAP_X168	MIKRAP_X168		3543
+htcmozart		MACH_HTCMOZART		HTCMOZART		3544
+htcgold			MACH_HTCGOLD		HTCGOLD			3545
+mt72xx			MACH_MT72XX		MT72XX			3546
+mx51_ivy		MACH_MX51_IVY		MX51_IVY		3547
+mx51_lvd		MACH_MX51_LVD		MX51_LVD		3548
+omap3_wiser2		MACH_OMAP3_WISER2	OMAP3_WISER2		3549
+dreamplug		MACH_DREAMPLUG		DREAMPLUG		3550
+cobas_c_111		MACH_COBAS_C_111	COBAS_C_111		3551
+cobas_u_411		MACH_COBAS_U_411	COBAS_U_411		3552
+hssd			MACH_HSSD		HSSD			3553
+iom35x			MACH_IOM35X		IOM35X			3554
+psom_omap		MACH_PSOM_OMAP		PSOM_OMAP		3555
+iphone_2g		MACH_IPHONE_2G		IPHONE_2G		3556
+iphone_3g		MACH_IPHONE_3G		IPHONE_3G		3557
+ipod_touch_1g		MACH_IPOD_TOUCH_1G	IPOD_TOUCH_1G		3558
+pharos_tpc		MACH_PHAROS_TPC		PHAROS_TPC		3559
+mx53_hydra		MACH_MX53_HYDRA		MX53_HYDRA		3560
+ns2816_dev_board	MACH_NS2816_DEV_BOARD	NS2816_DEV_BOARD	3561
+iphone_3gs		MACH_IPHONE_3GS		IPHONE_3GS		3562
+iphone_4		MACH_IPHONE_4		IPHONE_4		3563
+ipod_touch_4g		MACH_IPOD_TOUCH_4G	IPOD_TOUCH_4G		3564
+dragon_e1100		MACH_DRAGON_E1100	DRAGON_E1100		3565
+topside			MACH_TOPSIDE		TOPSIDE			3566
+irisiii			MACH_IRISIII		IRISIII			3567
+deto_macarm9		MACH_DETO_MACARM9	DETO_MACARM9		3568
+eti_d1			MACH_ETI_D1		ETI_D1			3569
+som3530sdk		MACH_SOM3530SDK		SOM3530SDK		3570
+oc_engine		MACH_OC_ENGINE		OC_ENGINE		3571
+apq8064_sim		MACH_APQ8064_SIM	APQ8064_SIM		3572
+arm			MACH_ARM		ARM			3573
+omap3			MACH_OMAP3		OMAP3			3574
+alps			MACH_ALPS		ALPS			3575
+tny_t3730		MACH_TNY_T3730		TNY_T3730		3576
+geryon_nfe		MACH_GERYON_NFE		GERYON_NFE		3577
+ns2816_ref_board	MACH_NS2816_REF_BOARD	NS2816_REF_BOARD	3578
+silverstone		MACH_SILVERSTONE	SILVERSTONE		3579
+mtt2440			MACH_MTT2440		MTT2440			3580
+ynicdb			MACH_YNICDB		YNICDB			3581
+bct			MACH_BCT		BCT			3582
+tuscan			MACH_TUSCAN		TUSCAN			3583
+xbt_sam9g45		MACH_XBT_SAM9G45	XBT_SAM9G45		3584
+enbw_cmc		MACH_ENBW_CMC		ENBW_CMC		3585
+msm8x60_dragon		MACH_APQ8060_DRAGON	APQ8060_DRAGON		3586
+ch104mx257		MACH_CH104MX257		CH104MX257		3587
+openpri			MACH_OPENPRI		OPENPRI			3588
+am335xevm		MACH_AM335XEVM		AM355XEVM		3589
+picodmb			MACH_PICODMB		PICODMB			3590
+waluigi			MACH_WALUIGI		WALUIGI			3591
+punicag7		MACH_PUNICAG7		PUNICAG7		3592
+ipad_1g			MACH_IPAD_1G		IPAD_1G			3593
+appletv_2g		MACH_APPLETV_2G		APPLETV_2G		3594
+mach_ecog45		MACH_MACH_ECOG45	MACH_ECOG45		3595
+ait_cam_enc_4xx		MACH_AIT_CAM_ENC_4XX	AIT_CAM_ENC_4XX		3596
+runnymede		MACH_RUNNYMEDE		RUNNYMEDE		3597
+play			MACH_PLAY		PLAY			3598
+hw90260			MACH_HW90260		HW90260			3599
+tagh			MACH_TAGH		TAGH			3600
+filbert			MACH_FILBERT		FILBERT			3601
+getinge_netcomv3	MACH_GETINGE_NETCOMV3	GETINGE_NETCOMV3	3602
+cw20			MACH_CW20		CW20			3603
+cinema			MACH_CINEMA		CINEMA			3604
+cinema_tea		MACH_CINEMA_TEA		CINEMA_TEA		3605
+cinema_coffee		MACH_CINEMA_COFFEE	CINEMA_COFFEE		3606
+cinema_juice		MACH_CINEMA_JUICE	CINEMA_JUICE		3607
+linux_pad		MACH_THEPAD		THEPAD			3608
+mx53_mirage2		MACH_MX53_MIRAGE2	MX53_MIRAGE2		3609
+mx53_efikasb		MACH_MX53_EFIKASB	MX53_EFIKASB		3610
+imx			MACH_IMX		IMX			3611
+stm_b2000		MACH_STM_B2000		STM_B2000		3612
+m28evk			MACH_M28EVK		M28EVK			3613
+pda			MACH_PDA		PDA			3614
+meraki_mr58		MACH_MERAKI_MR58	MERAKI_MR58		3615
+kota2			MACH_KOTA2		KOTA2			3616
+letcool			MACH_LETCOOL		LETCOOL			3617
+mx27iat			MACH_MX27IAT		MX27IAT			3618
+apollo_td		MACH_APOLLO_TD		APOLLO_TD		3619
+arena			MACH_ARENA		ARENA			3620
+gsngateway		MACH_GSNGATEWAY		GSNGATEWAY		3621
+lf2000			MACH_LF2000		LF2000			3622
+bonito			MACH_BONITO		BONITO			3623
+asymptote		MACH_ASYMPTOTE		ASYMPTOTE		3624
+bst2brd			MACH_BST2BRD		BST2BRD			3625
+tx335s			MACH_TX335S		TX335S			3626
+pelco_tesla		MACH_PELCO_TESLA	PELCO_TESLA		3627
+rrhtestplat		MACH_RRHTESTPLAT	RRHTESTPLAT		3628
+vidtonic_pro		MACH_VIDTONIC_PRO	VIDTONIC_PRO		3629
+pl_apollo		MACH_PL_APOLLO		PL_APOLLO		3630
+pl_phoenix		MACH_PL_PHOENIX		PL_PHOENIX		3631
+m28cu3			MACH_M28CU3		M28CU3			3632
+vvbox_hd		MACH_VVBOX_HD		VVBOX_HD		3633
+coreware_sam9260_	MACH_COREWARE_SAM9260_	COREWARE_SAM9260_	3634
+marmaduke		MACH_MARMADUKE		MARMADUKE		3635
+amg_xlcore_camera	MACH_AMG_XLCORE_CAMERA	AMG_XLCORE_CAMERA	3636
+omap3_egf		MACH_OMAP3_EGF		OMAP3_EGF		3637
+smdk4212		MACH_SMDK4212		SMDK4212		3638
+dnp9200			MACH_DNP9200		DNP9200			3639
+tf101			MACH_TF101		TF101			3640
+omap3silvio		MACH_OMAP3SILVIO	OMAP3SILVIO		3641
+picasso2		MACH_PICASSO2		PICASSO2		3642
+vangogh2		MACH_VANGOGH2		VANGOGH2		3643
+olpc_xo_1_75		MACH_OLPC_XO_1_75	OLPC_XO_1_75		3644
+gx400			MACH_GX400		GX400			3645
+gs300			MACH_GS300		GS300			3646
+acer_a9			MACH_ACER_A9		ACER_A9			3647
+vivow_evm		MACH_VIVOW_EVM		VIVOW_EVM		3648
+veloce_cxq		MACH_VELOCE_CXQ		VELOCE_CXQ		3649
+veloce_cxm		MACH_VELOCE_CXM		VELOCE_CXM		3650
+p1852			MACH_P1852		P1852			3651
+naxy100			MACH_NAXY100		NAXY100			3652
+taishan			MACH_TAISHAN		TAISHAN			3653
+touchlink		MACH_TOUCHLINK		TOUCHLINK		3654
+stm32f103ze		MACH_STM32F103ZE	STM32F103ZE		3655
+mcx			MACH_MCX		MCX			3656
+stm_nmhdk_fli7610	MACH_STM_NMHDK_FLI7610	STM_NMHDK_FLI7610	3657
+top28x			MACH_TOP28X		TOP28X			3658
+okl4vp_microvisor	MACH_OKL4VP_MICROVISOR	OKL4VP_MICROVISOR	3659
+pop			MACH_POP		POP			3660
+layer			MACH_LAYER		LAYER			3661
+trondheim		MACH_TRONDHEIM		TRONDHEIM		3662
+eva			MACH_EVA		EVA			3663
+trust_taurus		MACH_TRUST_TAURUS	TRUST_TAURUS		3664
+ns2816_huashan		MACH_NS2816_HUASHAN	NS2816_HUASHAN		3665
+ns2816_yangcheng	MACH_NS2816_YANGCHENG	NS2816_YANGCHENG	3666
+p852			MACH_P852		P852			3667
+flea3			MACH_FLEA3		FLEA3			3668
+bowfin			MACH_BOWFIN		BOWFIN			3669
+mv88de3100		MACH_MV88DE3100		MV88DE3100		3670
+pia_am35x		MACH_PIA_AM35X		PIA_AM35X		3671
diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 203da44..ef73ceb 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -123,6 +123,7 @@ static int sdio_bus_probe(struct device *dev)
 	const struct sdio_device_id *id;
 	int ret;
 
+	pr_warning("pia35x: %s: %s\n", __func__, drv->name);
 	id = sdio_match_device(func, drv);
 	if (!id)
 		return -ENODEV;
diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index c75c799..36dfcac 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -452,6 +452,7 @@ static int omap_hsmmc_reg_get(struct omap_hsmmc_host *host)
 		* we don't require a main regulator
 		* for MMC2 or MMC3
 		*/
+		pr_warning("%s: vmmc regulator missing for mmc.%d", __func__, host->id);
 		if (host->id == OMAP_MMC1_DEVID) {
 			ret = PTR_ERR(reg);
 			goto err;
diff --git a/drivers/net/wireless/wl12xx/wl1271_sdio.c b/drivers/net/wireless/wl12xx/wl1271_sdio.c
index 784ef34..96029b9 100644
--- a/drivers/net/wireless/wl12xx/wl1271_sdio.c
+++ b/drivers/net/wireless/wl12xx/wl1271_sdio.c
@@ -216,6 +216,7 @@ static int __devinit wl1271_probe(struct sdio_func *func,
 	int ret;
 
 	/* We are only able to handle the wlan function */
+	pr_warning("pia35x: wl1271 %d\n", func->num);
 	if (func->num != 0x02)
 		return -ENODEV;
 
